#+title: Doom Emacs Configuration
#+AUTHOR: Doter
#+DESCRIPTION: Doter's personal Doom Emacs config.
#+STARTUP: show2levels
* About Emacs & Doom Emacs

** Terminology
Emacs에서 사용하는 고유한 용어들을 알아보자.

- Cutting is called killing, Pasting is called yanking.
- The point refers to the cursor. The mark refers to the selected region

*Commands and Functions*
Commands are functions that  can be bound to a key (interactive) or run with ~M-x~. Most commands can also be run from evil's command line.




* About This Config
This is my personal Doom Emacs config.

* How To Config

For quick open config file use ~SPC-f-p~, or use my mapping for spcific files below:
- ~SPC = c~, config.org
- ~SPC = i~, init.el
- ~SPC = p~, package.el

Use ~M-x eval-buffer~ to evaluate the code and see if you like the way that Emacs behave. Also if you want to reload use ~SPC r~ key binding.

#+begin_src emacs-lisp
(map! :leader "r" (cmd! (save-buffer) (doom/reload)))
#+end_src

- [ ] K의 역할에 대해 설명
- [ ] gd의 역할에 대한 설명




*Packages*
To install a package directly from a particular repo, you’ll need to specify a :recipe. You’ll find documentation on what :recipe accepts here:

#+begin_src
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a PACKAGENAME.el file, or is located in a subdirectory of the repo, you’ll need to specify :files in the :recipe:

#+begin_src
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

If you add or remove package, shold excute ~doom sync~ command in shell.

** Reference
Doom Emacs provide built-in manual. You can using ~C-h i~ to search it. also you can look around modules typing ~C-= m~

Emacs Manual
[[https://trans.onionmixer.net/mediawiki/index.php?title=GNUEMACS_Manual][- GNU Emacs Korean Manual-onionmixer]]

For Org manual
[[https://orgmode.org/manual/index.html][- Org Mode-Manual]]
[[https://orgmode.org/worg/][- Worg]]

There many dotfiles.
- [[https://github.com/sunnyhasija/Academic-Doom-Emacs-Config/tree/master][sunyhasija/Academic-Doom-Eamcs-Config]]
- [[https://github.com/elken/doom?tab=readme-ov-file#dired][elken/doom]]
- [[https://github.com/dangirsh/.doom.d/blob/master/README.org][dangirsh/.doom.d]]


There many distribution.
[[https://github.com/jkitchin/scimax][- Scimax]]

There have several site that help you to config.
- [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs-Github]]

(defvar general-override-mode-map (make-sparse-keymap)
  "A keymap that will take priority over other minor mode keymaps.
This is only for non-evil keybindings (it won't override keys bound with
`evil-define-key'.")

** Function


~setq!~
변수를 설정한다.

~after!~
특정 패키지가 로드된 후에 설정을 적용한다.

*Hook*
A hook is a list of functions that are executed when certain events happen. Hooks are modified with the Emacs function ~add-hook~.

~remove-hook!~
특정 Hook를 제거한다.

~load!~ for loading external ~.el~ files relative to this one.
~use-package!~ for configuring packages

~add-load-path!~ for adding directories to the ~load-path~ where Emacs looks when you load packages with ~require~ or ~use-package~

~command!~
Command를 정의한다.

~add-to-list~
리스트에 요소를 추가한다.

** Major and Minor Modes

Major mode는 파일 형식에 따라 특정한 설정과 동작을 제공합니다.

** Key binding
Key bindings is organized in table format. While organizing keybinds, I prioritize listing only the most frequently used ones instead of documenting every single keybind. There are key bindings for Vanilla Eamcs, Doom Emacs, Evil, and key-chord. If there are overlapping keys, I selected and organized only the keys mostly used.

*User input*
Emacs recognizes control characters that are entered using modifier keys. Two commonly-used modifier keys are Control and Meta (usually labeled Alt).

~C-a~ is entered by holding down the Ctrl key while pressing a. Modifier keys can also be applied to non-alphanumerical characters, e.g., C-F1.

Simple characters and control characters, as well as certain non-keyboard inputs such as mous clicks, are collectively referred to as *input events*.

Emacs 명령어는 하나 또는 그 이상의 입력 이벤트로 호출된다.

A key sequence, or key for short, is a sequence of one or more input events that is meaningful as a unit. If a key sequence invokes a commands, we call it a complete key. If a key sequence isn't long enough to invoke a command, we call it a prefix key. For example ~C-x C-f~ is complete key, from the preceding example, ~C-x~ is prefix key. Every key sequence is either a complete key or a prefix key. A prefix key combines with the following input event to make a longer key sequence. There is no limit to the length of key sequences, but in practice they are seldom longer than three or four input events. You can't add input events onto a complete key.

*Numeric Arguments*
You can give any Emacs command a numeric argument (also called a prefix argument). Some commands interpret the argument as a repetition count.

*Key Notation*
키 바인딩을 할 때 사용할 키는 다음과 같이 표시한다.
~C-~, means (press and hold) the Control key.



~M-~, means the Meta key.
~S-~, means the Shift key.
~DEL~, means the Backspace key, not the Delete key.
~RET~, means the Return or Enter key.
~SPC~, means the Space bar.
~ESC~, means the Escape key.
~TAB~, means the Tab key.

For example, ~C-M-X~ (or, equivalently, ~M-C-x~) means press and hold both Control and Meta keys while hitting the ~x~ jey.

*Keybind Function*

- ~map!~
  ~(map! &rest REST)~
  A convenience macro for defining keybinds by Doom Emacs
  *Properties*
  :leader
  :localleader
  :mode [MODE(s)]           inner keybinds are applied to major MODE(s)
  :map [KEYMAP(s)]          inner keybinds are applied to KEYMAP(S)
  :prefix [PREFIX]          set keybind prefix for following keys. PREFIX
                            can be a cons cell: (PREFIX . DESCRIPTION)
  :prefix-map [PREFIX]      same as :prefix, but defines a prefix keymap
                            where the following keys will be bound. DO NOT
                            USE THIS IN YOUR PRIVATE CONFIG.
  :after [FEATURE]          apply keybinds when [FEATURE] loads
  :textobj KEY INNER-FN OUTER-FN  define a text object keybind pair
  :when [CONDITION]
  :unless [CONDITION]

  *States*
  ~:n~  normal
  :v  visual
  :i  insert
  :e  emacs
  :o  operator
  :m  motion
  :r  replace
  :g  global  (binds the key without evil current-global-map)

  States must be place right beforethe key string.
  ~(map! :leader :desc "Description" :n "C-c" #'dosomething)~

- ~remove-key-bindings~
키 바인딩을 할 때 사용하지 않는 키 바인드를 삭제하기로 했다. 키 바인드를 사용하지 않는 이유에는 크게 두 가지가 있다. 원래 사용하지 않는 기능이거나 또는 새로운 키 바인드에 의해 중복된 기능을 공유하는 경우가 그렇다. 이런 사용하지 않는 키 바인드를 제거하려고 하는데 왜냐하면 바인드된 키는 which-key에 뜨는데 사용하지 않는 키가 뜨면 원하는 키 바인드를 빠르게 찾을 수 없기 때문이다. 그리고 실수로 누르게 되서 키 바인드가 실행될 수도 있기 때문이다.

#+begin_src emacs-lisp
(defun remove-key-bindings (mode key-list)
  "Remove multiple key bindings from the given MODE's keymap."
  (let ((keymap (symbol-value mode)))
    (if (keymapp keymap)
        (dolist (key key-list)
          (define-key keymap (kbd key) nil)))))
#+end_src

다음과 같이 사용하면 된다.
#+begin_src
(remove-key-bindings 'exmaple-map
                     '("a" "b" "C-a"))
#+end_src

만약 특정 mode map을 전부 제거하고 원하는 키 바인딩을 하고 싶다면 다음의 명령어로 제거할 수 있다. 다만 추천하지는 않는게 Emacs를 처음 실행하면 괜찮지만 ~doom/reload~를 사용하고 나면 전부 원래 키 바인드로 초기화가 된다. 이유는 잘 모르겠다.
처음에 모든 키를 제거하고 원하는 키 바인드를 하려고 했으나 위와 같은 이유, 그리고 새로 모든 걸 적어야 하는 것이 부담이 되서 그냥 불필요한 키 맵을 제거하고 원하는 키만 남기고 필요한 것만 추가로 맵핑을 하기로 결정했다.

#+begin_src
;; (after! org
;;   (setq org-mode-map (make-sparse-keymap)))

;; (after! evil
;;   (setq evil-normal-state-map (make-sparse-keymap)
;;         evil-insert-state-map (make-sparse-keymap)
;;         evil-visual-state-map (make-sparse-keymap)
;;         evil-motion-state-map (make-sparse-keymap)))

;; (after! evil-org
;;   (setq evil-org-mode-map (make-sparse-keymap))

;; 대부분의 리더키와 바인딩된 키가 있음.
;; doom-leader-map
#+end_src

*** Evil*

- [[https://evil.readthedocs.io/en/latest/index.html][Evil-Manual]]

Evil is an extensible vi layer for Emacs. It emulates the main features of vim.

Evil uses the term 'state' for what is called a "mode" in regular vi usage, because "modes" are understood in Emacs terms to mean something else.

- Normal state ~<N>~
  The state which the main body of vi bindings are defined.
- Insert state ~<I>~
  The state for selecting text regions.
- Visual state ~<V>~
  A state for selecting text regions.
- Replace state ~<R>~
  A special state that replaces text instead of inserting.
- Operator-pending state ~<O>~
  A special state entered after launching an operator, but before specifying the corresponding motion or text object.
- Motion state ~<M>~
  A special state useful for buffers that are read-only, where motions are available but editing operations are not.
- Emacs state ~<E>~
  A state that as closely as possible mimics default Emacs behaviour, by eliminating all vi bindings, except for ‘C-z’, to re-enter normal state.

#+begin_src emacs-lisp
(setq evil-echo-state nil)             ; signal the current state in the echo area.
(setq evil-toggle-key nil)             ; don't use emacs state, let's disable it. TODO not work
#+end_src

| Keybind | Description                          |
|---------+--------------------------------------|
| a / A   | Append / Append at end of line       |
| c / C   | Change / Change the whole line       |
| d / D   | Delete / Delete line                 |
| i / I   | Insert / Insert at beginning of line |
| K       | Look up document                     |
| m       | Set marker                           |
| o / O   | Open line below / above              |
| p / P   | Paste after / before                 |
| q / Q   | Record macro / Execute last macro    |
| r / R   | Replace / Enter replace state        |
| x / X   | Delete char / Delete backward char   |
| y / Y   | Yank / Yank line                     |
| zz      | Toggle fold                          |
| za / zc | Open folds / Close folds             |
| g] / g[ | Go to last change / Reverse          |
| ~=c~      | Invert case for region               |
| ~=w~      | Invert case of the word at point     |
| ~=f~      | Invert case of first char of word    |
| .       | Repeat last command                  |
| @       | Execute macro                        |
| "       | Use register                         |
| < / >   | Shift left / right                   |
| u       | Undo                                 |
| C-r     | Redo                                 |

- ~s~, ~S~ 키는 subsititue 키인데 이는 ~vc~로 대체하기로 한다.

#+begin_src emacs-lisp
;; TODO s, S 키도 후보에 넣기
(remove-key-bindings 'evil-normal-state-map
                     '("s" "S" "<insert>" "<insertchar>" "gu" "gf" "g~"
                       "zo" "zO" "zc" "zr" "zm" "za" "zr" "zm" "J"
                       "z=" "C-n" "C-p" "C-t" "C-." "M-." "=" "~"))

(defun dt/invert-case-at-word ()
  "Invert the case of the word at point."
  (interactive)
  (let ((bounds (bounds-of-thing-at-point 'word)))
    (if bounds
        (evil-invert-char (car bounds) (cdr bounds))
      (message "No word at point"))))

(defun dt/invert-case-first-char-at-word ()
  "Invert the case of the first character of the word at point."
  (interactive)
  (let ((bounds (bounds-of-thing-at-point 'word)))
    (if bounds
        (let ((start (car bounds))) ;; 단어의 시작 위치
          (evil-invert-case start (1+ start))) ;; 첫 글자만 처리
      (message "No word at point"))))

;; TODO 현재 커서의 element를 fold하는 기능.
(map! :map evil-normal-state-map
      "zz" #'evil-toggle-fold
      "za" #'evil-open-folds
      "zc" #'evil-close-folds
      "g]" #'evil-goto-last-change
      "g[" #'evil-goto-last-change-reverse
      "=c" #'evil-invert-char
      "=w" #'dt/invert-case-at-word
      "=f" #'dt/invert-case-first-char-at-word)
#+end_src

window-map

#+begin_src emacs-lisp
;; evil-window-map
;; (define-key evil-window-map "b" 'evil-window-bottom-right)
;; (define-key evil-window-map "c" 'evil-window-delete)
;; (define-key evil-window-map "f" ffap-other-window)
;; (define-key evil-window-map "h" 'evil-window-left)
;; (define-key evil-window-map "H" 'evil-window-move-far-left)
;; (define-key evil-window-map "j" 'evil-window-down)
;; (define-key evil-window-map "J" 'evil-window-move-very-bottom)
;; (define-key evil-window-map "k" 'evil-window-up)
;; (define-key evil-window-map "K" 'evil-window-move-very-top)
;; (define-key evil-window-map "l" 'evil-window-right)
;; (define-key evil-window-map "L" 'evil-window-move-far-right)
;; (define-key evil-window-map "n" 'evil-window-new)
;; (define-key evil-window-map "o" 'delete-other-windows)
;; (define-key evil-window-map "p" 'evil-window-mru)
;; (define-key evil-window-map "q" 'evil-quit)
;; (define-key evil-window-map "r" 'evil-window-rotate-downwards)
;; (define-key evil-window-map "R" 'evil-window-rotate-upwards)
;; (define-key evil-window-map "s" 'evil-window-split)
;; (define-key evil-window-map "S" 'evil-window-split)
;; (define-key evil-window-map "t" 'evil-window-top-left)
#+end_src


evil-insert-state-map

| Keybind   | Description                  |
|-----------+------------------------------|
| C-h / C-l | Move backward / forward char |
| C-j / C-k | Move next / previous line    |


#+begin_src emacs-lisp
(remove-key-bindings 'evil-insert-state-map
                     '("C-q" "C-v" "C-k" "C-o" "C-y" "C-e" "C-p"
                       "C-x C-n" "C-x C-p" "C-t" "C-d" "C-a" "C-@"
                       "<insert>" "C-j" "C-r" "C-u" "C-w" "C-z"
                       "C-x C-o" "C-x C-s" "C-x s"))

;; TODO 제대로 작동하지 않음
(map! :map evil-insert-state-map
      "C-h" #'evil-forward-char
      "C-j" #'evil-next-line
      "C-k" #'evil-previous-line
      "C-l" #'evil-backward-char)
#+end_src

evil-replace-state-map

| Keybind   | Description                  |
|-----------+------------------------------|
| C-h / C-l | Move backward / forward char |
| C-j / C-k | Move next / previous line    |
| C-n       | Completion                   |
| C-g       | escape                       |
|           |                              |


#+begin_src emacs-lisp
(remove-key-bindings 'evil-replace-state-map
                     '("C-q" "C-v" "C-k" "C-o" "C-y" "C-e" "C-p"
                       "C-x C-n" "C-x C-p" "C-t" "C-d" "C-a" "C-@"
                       "C-r" "C-u" "C-w" "S-<left>" "S-<right>"))

;; TODO 제대로 작동하지 않음
(map! :map evil-replace-state-map
      "C-h" #'evil-forward-char
      "C-j" #'evil-next-line
      "C-k" #'evil-previous-line
      "C-l" #'evil-backward-char)
#+end_src


general-override-mode-map
evil-replace-state-map


자주 사용하는 커맨드는 빠르게 치기 때문에 오타가 나기 쉽다. 이때 자주 생기는 오타는 의도한 대로 작도되게 만들었다.

#+begin_src emacs-lisp
(after! evil
  (evil-ex-define-cmd "W" 'save-buffer)
  (evil-ex-define-cmd "Q" 'evil-save-modified-and-close))
#+end_src



*** 키 바인딩과 함수

~map!~​를 사용해서 키 바인딩에 함수에 인수를 전달하는 형태로 설정하려면 ~cmd!~​와 람다 함수를 활용하면 됩니다.

- ~cmd!~

- ~lambda~




*Key-Chord*
Key Chord는 Emacs에서 두 개의 키를 빠르게 동시에 입력하여 특정 명령을 실행할 수 있도록 하는 도구다.


*Tip*
Want to find what a key does, typing ~C-h k (describe-key)~, followed by the key of interesst.

나의 경우 Evil모드에 많이 의존하기 때문에 Eamcs의 키맵핑은 ~C-g~와 ~C-h~ 정도만 사용한다.

키맵에 대해 알고 싶다면 ~M-x describe keymap~을 눌러 확인 가능한 모든 키맵에 대해 둘러 볼 수 있다.

#+begin_src emacs-lisp
(after! which-key
  (setq which-key-idle-delay 0.3
        which-key-idle-secondary-delay 0.1))
#+end_src

키 바인딩을 할 때 ~M-x~를 사용해서 명령어에 바인딩된 키를 찾을 수 있다.

키 바인딩을 할 때 ~:desc~로 바인딩된 키에 대한 설명을 넣을 수 있다. 이때 만약 바인딩된 command가 읽고 이해하기 어려운 경우, 설명을 따로 추가한다.

키 바인딩을 할 때 직접 만든 함수를 command로 사용하는 경우 함수의 이름 앞에 ~dt/~를 넣어서 내가 만든 것이라고 표시했다.

모듈과 관련된 설정들은 ~/.config/emacs/modules 에서 찾을 수 있다.

다음의 각 map에 ~K~를 눌러서 바인딩된 키 목록을 확인할 수 있다.


#+begin_src emacs-lisp
;; evil-motion-state-map
;; evil-normal-state-map
;; evil-insert-state-map
#+end_src







| Keybind | Description |
|---------+-------------|
| <L>-f   | 파일과      |

** Faces
Emacs can display text in several different styles, called faces. Most major modes assign faces to the text automatically. When customizing the face, you can use either a color name or an RGB triplet.

Here are the standard faces for specifying text appearance.
- default
- bold
- italic
- bold-iatlic
- underline
- fixed-pitch, forces use of a fixed-width font.

** Troubleshooting

*** Wrong type argument: commandp
함수가 유효하지 않거나 정의되지 않은 경우에는 함수로 직접 호출되야 하지만, 리스트로 작성되어있어서 유효한 명령이 아닌 경우가 있다. 즉 Emacs의 command는 interactive한 함수여야 한다. 따라서 ~lambda ~interactive~ 선언을 해야 한다.

* General Configuration
설정을 로딩하는 시간을 절약하기 위해, Emacs를 서버-클라이언트 형태로 실행하는 방식을 사용한다. 실제 실행 속도는 변하지 않지만, 서버-클라이언트 방식은 한번 로딩이 끝나면 클라이언트를 여러 개 실행해도 다시 로딩할 필요가 없다는 장점이 있다.

#+begin_src emacs-lisp
(require 'server)
(unless (server-running-p) (server-start))
#+end_src

서버로 Emacs를 실행할 경우 기본적인 ~save-buffers-kill-terminal~ 단축키를 사용하면 서버 자체가 죽기 때문에, 이를 방지하기 위해 기본적으로 클라이언트 프레임만 닫고 서버를 닫는 함수를 따로 만든다.

#+begin_src emacs-lisp
(defun dt/done ()
  (interactive)
  (server-edit)
  (make-frame-invisible nil t))

(map! :leader :n "k" #'dt/done)
#+end_src

#+begin_src emacs-lisp
;; personal information
(setq user-full-name "doter"
      user-mail-address "hollywooddreaming21@google.com")

;; autosave and backup
(setq auto-save-default t
      make-backup-files t)

;; kill emacs without confirm
(setq confirm-kill-emacs nil)

;; input method
(setq default-input-method "korean-hangul")
(global-set-key (kbd "<Hangul>") 'toggle-input-method)
(global-set-key (kbd "C-<Hangul>") 'toggle-input-method)
(global-set-key (kbd "M-<Hangul>") 'toggle-input-method)

;; Emacs 종료 시 세션 저장 및 복원
(setq desktop-save-mode t)

;; remap <localleader> from 'SPC m' to ','
(setq doom-localleader-key ","
      doom-localleader-alt-key "M-,")

;; for macOS
;; (if (featurep :system 'macos)
;;   (setq mac-command-modifier 'meta
;;         mac-option-modifier 'none
;;         mac-right-option-modifier 'super))
#+end_src

설정 파일에 사용할 몇가지 변수를 설정했다.

#+begin_src emacs-lisp
(defconst my/home-dir "/home/doter/")

;; Basic directory
(defconst my/download-dir (concat my/home-dir "Download/"))

;; Config directory
(defconst my/config-dir (concat my/home-dir ".config/"))
(defconst my/dotfiles-dir (concat my/home-dir ".dotfiles/"))
(defconst my/wiki-dir (concat my/home-dir "wiki/"))
(defconst my/doom-dir (concat my/config-dir "doom/"))
(defconst my/emacs-dir (concat my/config-dir "emacs/"))
(defconst my/emacs-modules-dir (concat my/emacs-dir "modules/"))
#+end_src

** Theme
I use catppuccin to linux enviroment theme. for many program also use this theme. 일관성을 위해 set Catppuccin in Emacs.

#+begin_src emacs-lisp :tangle yes
;; (setq doom-theme 'catppuccin)
(setq doom-theme 'doom-one)
#+end_src

Settings related to fonts within Doom Emacs:
- 'doom-font' -- standard monospace font that is used for most things in Emacs.
- 'doom-variable-pitch-font' -- variable font which is useful in some Emacs plugins.
- 'doom-big-font' -- used in doom-big-font-mode; useful for presentations.
- 'font-lock-comment-face' -- for comments.
- 'font-lock-keyword-face' -- for keywords with special significance like 'setq' in elisp.


추천하는 폰트로는
- =SauceCodePro Nerd Font=, org 테이블의 modern 패키지의 한글폭 때문에 제대로 안보인다는 단점이 있음.
- =D2CodingLigature Nerd Font=
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "D2CodingLigature Nerd Font" :size 14)
      doom-unicode-font (font-spec :family "Symbols Nerd Font Mono" :size 14)
      doom-emoji-font (font-spec :family "Noto Color Emoji" :size 14))

;; (after! doom-themes
;;   (setq doom-themes-enable-bold t
;;         doom-themes-enable-italic t))
#+end_src
** Lookup Provider URLs
#+begin_src emacs-lisp
(setq +lookup-provider-url-alist
      '(("Doom Emacs issues" "https://github.com/hlissner/doom-emacs/issues?q=is%%3Aissue+%s")
        ("StackOverflow"     "https://stackoverflow.com/search?q=%s")
        ("Google" +lookup--online-backend-google "https://google.com/search?q=%s")
        ("Github"            "https://github.com/search?ref=simplesearch&q=%s")
        ("Youtube"           "https://youtube.com/results?aq=f&oq=&search_query=%s")
        ("Arch Wiki"         "https://wiki.archlinux.org/index.php?search=%s&title=Special%3ASearch&wprov=acrw1")
        ("AUR"               "https://aur.archlinux.org/packages?O=0&K=%s")))
#+end_src

** Dashboard




[[https://discourse.doomemacs.org/t/how-to-change-your-splash-screen/57][dashboard]]
#+begin_src emacs-lisp
(setq fancy-splash-image (concat doom-private-dir "splash.svg"))



#+end_src








solaire
https://github.com/hlissner/emacs-solaire-mode
** Registers & Bookmarks
*Registers*
Registers are compartments where you can temporarily save various types of data. They are incredibly versatile and allow users to perform complex tasks more efficiently by storing and retrieving across buffers or sessions. Registers are typically used to save: Text or snippets of code, positions within a buffer, rectangles (multi-line regions), numbers, window and frame.

Each register has a name that consists of a single character. The letter (case-sensitive) and number can use. The regisuter information until you store something else in it.

*Saving Positions in Registers*
| Keybind          | Description                                                     |
|------------------+-----------------------------------------------------------------|
| C-x r SPC <Char> | Record the position of point and the current buffer in register |
| C-x r j <Char>   | Jump to the position and buffer saved in register               |
| C-x r s <Char>   | Copy region into register                                       |
| C-x r i <Char>   | Insert text from register                                       |
| C-x r r <char>   | Copy the rectangle into register                                |
| C-x r i <Char>   | Insert the rectangle sotred in register                         |





For bookmarks
#+begin_src emacs-lisp
(setq bookmark-default-file "~/.config/doom/bookmarks")

(map! :leader
      (:prefix ("b", "buffer")
       :desc "List bookmarks"         "l" #'list-bookmarks
       :desc "Jump to the bookmark"   "g" #'bookmark-jump
       :desc "Delete bookmark"        "M" #'bookmark-set
       :desc "Save bookmarks to file" "w" #'bookmark-save))
#+end_src

** 성능
성능이 확실하지 않기 때문에 확인이 필요하다.
#+begin_src emacs-lisp
(run-with-idle-timer 10 t #'garbage-collect)
#+end_src

* Navigation


#+begin_src emacs-lisp
(pixel-scroll-precision-mode)
#+end_src



| Keybind          | Description                      |
|------------------+----------------------------------|
| [Char] h/l   <N> | Move cursor character right/left |
| [Char] j/k   <N> | Move curosr down/up [Char] lines |
|                  |                                  |

#+begin_src emacs-lisp
(setq evil-want-C-i-jump t
      evil-want-C-u-delete nil                ; C-u to scroll up, so disable it
      evil-want-C-u-scroll t
      evil-want-C-d-scroll t
      evil-want-C-w-delete nil                ; C-w to delete word in insert mode
      evil-want-C-w-in-emacs-state nil
      evil-want-Y-yank-to-eol t               ; yank to the end of line.
      evil-disable-insert-state-bindings nil) ; 잘 모르겠음.

(setq evil-repeat-move-cursor nil             ; whether repeating don't move cursor REVIEW 시범삼아 사용
      evil-move-cursor-back t)
#+end_src

#+begin_src emacs-lisp
      ;; beginning & end of line
(map! :nv "H" #'move-beginning-of-line
      :nv "L" #'move-end-of-line)
#+end_src

I want ~j, ~k~ navigate by visual lines rather than physical line. so I set ~evil-respect-visual-line-mode~ as ~t~. This variable must be set before Evil isloaded. so I put this setting in ~init.el~ above all module.

I don't like having to keep moving my eyes to find the cursor position while editing a file. Therefore, I make the cursor position was always centered. It may not work with some special buffers and other navigation commands, so an update is required.

#+begin_src emacs-lisp
(advice-add 'evil-previous-line :after #'evil-scroll-line-to-center)
(advice-add 'evil-next-line :after #'evil-scroll-line-to-center)
(advice-add 'evil-previous-visual-line :after #'evil-scroll-line-to-center)
(advice-add 'evil-next-visual-line :after #'evil-scroll-line-to-center)
(advice-add 'evil-scroll-up :after #'evil-scroll-line-to-center)
(advice-add 'evil-scroll-down :after #'evil-scroll-line-to-center)

;; ;; TODO 스크롤 수가 이상함.
;; (advice-add 'evil-scroll-line-up :after #'evil-scroll-line-to-center)
;; (advice-add 'evil-scroll-line-down :after #'evil-scroll-line-to-center)
;; (map! :nvi "C-e" (cmd! (evil-scroll-line-down 3) (evil-scroll-line-to-center 0)))
;; (map! :nvi "C-y" (cmd! (evil-scroll-line-up 3) (evil-scroll-line-to-center 0)))
#+end_src

*Search and Jump*

나는 window를 여러개 켜놓고 작업을 한다. 이때 다른 창에서 이어서 작업을 하려면 window move를 사용하고 스크롤을 해야하는데 이는 매우 번거롭다. 나는 avy로 모든 창에서 문자를 검색하여 라인 그리고 특정 단어로 이동하게 만들었다.

#+begin_src emacs-lisp
(setq avy-all-windows t)  ;; avy command for all window

(after! evil
 (map! :map evil-normal-state-map
       :prefix ("g a" . "avy")
       :desc "Jump to key"    "a" #'evil-avy-goto-char-timer
       :desc "Jump to 2 char" "c" #'evil-avy-goto-char-2
       :desc "Jump to word"   "w" #'evil-avy-goto-word-0
       :desc "Jump to line"   "l" #'evil-avy-goto-line))
#+end_src

* Editing Text

Delete trailing spaces when save.
#+begin_src emacs-lisp
(add-hook 'before-save-hook #'whitespace-cleanup)
#+end_src

#+begin_src emacs-lisp
(setq-default sentence-end-double-space nil)
#+end_src

#+begin_src emacs-lisp
;; (key-chord-define-global ";s" (lambda () (interactive) (insert "*")))
#+end_src

* UI
*Frame*
graphical window or terminal screen occupied by Emacs.

Frame Title은 Emacs 윈도우 상단에 있는 타이틀바에 표시되는 텍스트를 말한다. 이 타이틀은 현재 Emacs 세션이나 특정 버퍼에 대한 정보를 보여주기 위해 사용한다. 다만 대부분의 작업을 윈도우 타이틀바가 없는 Linux 환경에서 작업하고 있기 때문에 그대로 두어도 상관이 없지만 혹시나 Frame Title이 필요한 경우를 대비해서 다음의 형식으로 title을 표시하도록 했다.

#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        "%b"
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p) " ◉ %s" "  ●  %s - Emacs") project-name))))))
#+end_src

*Menu bar*
On a graphical display, Position at top of the frame. Menu bar allows you to access commands via a series of menus.

*Tool bar*
On a graphical display, Position at below the menu bar. a row of icons that perform editing command when you click on them.

#+begin_src emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(scroll-bar-mode 0)
#+end_src

*Echo area*
The Echo Area in Emacs is a single-line space located at the bottom of the frame. It displays messages, command results, and notifications form Emacs. Additionally, it serves as a prompt for user input during interactive commands.

The echo area is also used to display the minibuffer, a special window where you can input arguments to commands. When the minibuffer is in use, the text displayed in the echo area begins with a prompt string, and the active cursor appears within the minibuffer, which is temporarily considered the selected window.

Informative echo area messages are saved in a special buffer named *Messages*, If you miss a message that appeared briefly on the screen, you can switch to the *Messages* buffer to see it.

The *Messages* buffer is limited to a certain number of lines, or can disaply logging. I limit it as 100 lines

#+begin_src emacs-lisp
(setq message-log-max 100)
#+end_src

*Window*
Window is where display files content and editing happens. You can subdivide this window horizontally or verically to create multiple windows, each of which can independently display a buffer. The buffer displayed in the selected window is called the current buffer.

Thin line separating windows
#+begin_src emacs-lisp
;; (set-face-background 'vertical-border "black")
;; (set-face-background 'vertical-border (face-background 'vertical-border))
#+end_src

#+begin_src emacs-lisp
;; Disable s-s keys
(after! evil
  (map! :n "ss" #'+evil/window-split-and-follow
        :n "sv" #'+evil/window-vsplit-and-follow
        :n "sh" #'evil-window-left
        :n "sj" #'evil-window-down
        :n "sk" #'evil-window-up
        :n "sl" #'evil-window-right
        ;; Move window
        :n "Sh" #'+evil/window-move-left
        :n "Sj" #'+evil/window-move-down
        :n "Sk" #'+evil/window-move-up
        :n "Sl" #'+evil/window-move-right))

(defun dt/save-and-close-other-buffers ()
  "Save all buffers except the current one, then close them."
  (interactive)
  (let ((current-buffer (current-buffer)))
    (save-some-buffers t)
    (mapc (lambda (buffer)
            (unless (eq buffer current-buffer)
              (with-current-buffer buffer
                (when (buffer-file-name)
                  (save-buffer)))
              (kill-buffer buffer)))
          (buffer-list))
    (message "All other buffers saved and closed!")))

(defun my-save-and-close-window ()
  "Save the current buffer and close the window.
If the buffer cannot be saved, just close the window."
  (interactive)
  (if (and (buffer-file-name) (buffer-modified-p))
      (progn
        (save-buffer)
        (delete-window))
    (delete-window)))

(map! :leader
      :desc "Save & close other buffers"
      "qo" #'save-and-close-other-buffers)

(map! :n "qq" #'my-save-and-close-window
      :n "qo" #'dt/save-and-close-other-buffers)

;; t로 하면 커서가 새로 생긴 창으로 움직이지 않음. 왜인지 모르겠음.
(setq evil-split-window-below nil
      evil-vsplit-window-right nil)
#+end_src

간편하게 창을 생성하기 위해 가장자리로 이동하면 새로운 창을 생성하도록 했다.

#+begin_src emacs-lisp
(setq windmove-create-window t)
#+end_src

필요에 의해서 가장 오른쪽과 왼쪽에 창을 분할하는 함수를 만들었다.

#+begin_src emacs-lisp
;; TODO 버퍼를 선택하게하는 수정이 필요함.
(defun dt/create-window-at-far-right (file)
  "Move the current window to the far-right and open FILE.
If no FILE is provided, prompt the user to select one."
  (interactive "fSelect file: ")
  (evil-window-vsplit)
  (evil-window-move-far-right)
  (find-file file))

(defun dt/create-window-at-far-left (file)
  "Move the current window to the far-left and open FILE.
If no FILE is provided, prompt the user to select one."
  (interactive "fSelect file: ")
  (evil-window-vsplit)
  (evil-window-move-far-left)
  (find-file file))
#+end_src



*Buffer*

#+begin_src emacs-lisp
(map! :n "<DEL>" #'previous-buffer
      :n "S-<DEL>" #'next-buffer)
#+end_src

- [ ] *Fringe*

#+begin_src emacs-lisp
(setq display-line-numbers-type nil)
#+end_src


#+begin_src emacs-lisp
(setq truncate-string-ellipsis "…") ; Unicode ellispis are nicer than "..."
#+end_src


*Cursor & Point*
The cursor in the selected window shows the location where most editing comamnds take effect, which is called point. By defalut, the cursor in the selected window is drawn as a solid block and appears to be on a character, but you should think of point as between two character; it is situated before the character under the cursor.

If you are editing several files Emacs, each in its own buffer, each buffer has its own value of point. A buffer that is not currently displayed remembers its value of point if you later display it again. Futhermore, if a buffer is displayed in multiple window, each of those windows has its own value of point.

#+begin_src emacs-lisp
(blink-cursor-mode t)
(setq x-stretch-cursor t) ;; 커서가 텍스트의 크기에 맞춰서 늘어난다.

;; Evil mode cursor customization
(setq evil-normal-state-cursor '("#89b4fa" box)
      evil-insert-state-cursor '("#a6e3a1" (bar . 3))
      evil-visual-state-cursor '("#f9e2af" box)
      ;; evil-replace-state-cursor
      ;; evil-operator-state-cursor
      ;; evil-motion-state-cursor
      ;; evil-emacs-state-cursor
)
#+end_src

커서의 색상을 input method에 따라서 변경하도록 설정한다.

#+begin_src emacs-lisp
;; (defun set-cursor-color-based-on-input-method ()
;;   "Set cursor color based on the current input method.
;; Red for Korean, Blue for English."
;;   (if (string= current-input-method "korean-hangul")
;;       (set-cursor-color "red")
;;     (set-cursor-color "blue")))


;; (add-hook 'input-method-deactivate-hook 'update-cursor-color)
;; (add-hook input-method-activate-hook 'update-cursor-color)

;; Initialize cursor color when Emacs starts
;; (add-hook 'after-init-hook 'update-cursor-color)
#+end_src

#+begin_src emacs-lisp
;; (defun update-cursor-color-based-on-input-method ()
;;   "Update cursor color based on the current input method."
;;   (if (string= current-input-mehtod "korean-hangul")
;;       (set-cursor-color "red")
;;     (set-cursor-color "green")))

;; ;; `toggle-input-method` 실행 시 커서 색상 업데이트
;; (advice-add 'toggle-input-method :after
;;             (lambda () (update-cursor-color-based-on-input-method)))

;; ;; Emacs 시작 시 초기 커서 색상 설정
;; (add-hook 'after-init-hook 'update-cursor-color-based-on-input-method)
#+end_src
** Popup Rules
이맥스에서 몇가지 자주 쓰는 버퍼들이 정해진 위치에 표시되도록 해서 레이아웃을 망치지 않고 작업 효율을 높이도록 한다. DOOM 이맥스는 기본 키 바인딩인 ‘SPC ~’ 조합을 사용해서 해당 버퍼의 윈도우를 빠르게 토글 시킬 수 있어서 정말 편하다.

#+begin_src emacs-lisp
;; (set-popup-rule! "^\\*Messages\\*" :ttl t :side 'bottom :height 12 :quit t)
;; (set-popup-rule! "^\\*doom:vterm*" :ttl t :side 'bottom :height 20 :quit t)
;; (set-popup-rule! "^\\*npm*" :ttl t :side 'bottom :height 20 :quit t)
;; (set-popup-rule! "^\\*Flycheck*" :ttl t :side 'bottom :height 20 :quit t)
#+end_src

** Modeline
At the bottom of each window and above the echo area is a mode line, Which describes what is going on tin the current buffer.

파일의 인코딩 정보가 'UTF-8' 인코딩과 'LF' 끝내기 형식을 사용하는 경우, modeline에 'LF UTF-8'의 인코딩 정보를 숨기고 그 외의 경우는 표시하도록 설정한다.

Conditonally hide the default file encoding (~LF UTF-8~).

#+begin_src emacs-lisp
(defun modeline-contitional-buffer-encoding ()
  "Hide \"LF UTF-8\" in modeline.

It is expected of files to be encoded with LF UTF-8, so only show
the encoding in the modeline if the encoding is worth notifying
the user."
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'modeline-contitional-buffer-encoding)
#+end_src

doom-modeline-segment로 검색하면 요소가 많이 나온다.
https://github.com/seagle0128/doom-modeline]]

Show pdf-icon, pdf-pages.

#+begin_src emacs-lisp
;; (doom-modeline-def-segment buffer-name
;;   "Display the current buffer's name, without any other information."
;;   (concat
;;    (doom-modeline-spc)
;;    (doom-modeline--buffer-name)))

;; (doom-modeline-def-segment pdf-icon
;;   "PDF icon from nerd-icons."
;;   (concat
;;    (doom-modeline-icon sucicon "nf-seti-pdf" nil nil
;;    (doom-modeline-spc)
;;                        :face (if (doom-modeline--active)
;;                                  'nerd-icons-red
;;                                'mode-line-inactive)
;;                        :v-adjust 0.02)))

;; (defun doom-modeline-update-pdf-pages ()
;;   "Update PDF pages."
;;   (setq doom-modeline--pdf-pages
;;         (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
;;               (total-page-str (number-to-string (pdf-cache-number-of-pages))))
;;           (concat
;;            (propertize
;;             (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
;;                     " P" current-page-str)
;;             'face 'mode-line)
;;            (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

;; (doom-modeline-def-segment pdf-pages
;;   "Display PDF pages."
;;   (if (doom-modeline--active) doom-modeline--pdf-pages
;;     (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))
#+end_src

Modline에 Copilot의 활성화 여부를 표시한다.

#+begin_src emacs-lisp
(display-time-mode t) ;; display time in modeline
(setq! display-time-24hr-format t
       display-time-default-load-average nil)

;; TODO UTF를 추가해야 함.
(after! doom-modeline
  (doom-modeline-def-segment copilot
    "Show Copilot status in modeline."
    (if (bound-and-true-p copilot-mode)
        ""
      ""))
  (doom-modeline-def-modeline 'main
    '(bar modals matches buffer-info vcs)
    '(input-method misc-info buffer-position copilot major-mode check time))
  (setq! doom-modeline-buffer-file-name-style 'relative-to-project
         doom-modeline-icon t
         doom-modeline-major-mode-icon t
         doom-modeline-buffer-modification-icon nil
         doom-modeline-position-column-format '("C%c")
         doom-modeline-position-column-line-format '("L%l")
         doom-modeline-modal-modern-icon nil))
#+end_src



Rainbow mode displays the actual color for any hex value color. The following creates a global minor mode for rainbow-mode and enables it. (exception: org-agenda-mode, since ranbow-mode destroys all highlighting in org-agenda)

#+begin_src emacs-lisp
(define-globalized-minor-mode global-rainbow-mode rainbow-mode
 (lambda ()
   (when (not (memq major-mode
               (list 'org-agenda-mode)))
     (rainbow-mode 1))))
(global-rainbow-mode 1)
#+end_src

*Line Wrapping*
When a line of text in the buffer (a logical line) is too long to fit in the window, and Eamcs displays it as two or more screen lines, or visual lines. This is *line wrapping* or *continuation*, and the long logical line is called a *continued line*. Emacs indicates line wrapping with small bent arrows in the left and right window fringes.

*Line Truncation*
Emacs can optionally truncate long logical lines insted of continuing them. This means that every logical line occupies a single screen line; if it is longer than the width of the window, the rest of the line is not displayed. On a graphical display, a truncated line is indicated by a small straight arrow in the right fringe.

cursor를 위 아래로 이동시키거나 화면을 Scroll 할 떄, logical lines은 디테일한 이동이 되지 않기 때문에 screen lines를 통해 키 바인딩을 다시 하였다.;

#+begin_src emacs-lisp
(setq truncate-lines nil)
#+end_src

** Buffer
Emacs가 파일 시스템에서 파일이 변경될 때마다 버퍼를 자동으로 갱신하여 최신 파일 내용을 표시한다. 파일 변경은 2초마다 확인한다.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq auto-revert-interval 2)
#+end_src

*Minibuffer*
The minibuffer is where Emacs commands read complicated arguments, such as file names, buffer names, Emacs command names, or Lisp expressions. We call it the "minibuffer" because it's a special-purpose buffer wuth a small amount of screen space.


*** TODO Visual-fill-column
Keep the content centered on the page when writing org documents.
from ~visual-fill-column~ package.

#+begin_src emacs-lisp
(use-package! visual-fill-column
  :custom
  (visual-fill-column-width 300)
  (visual-fill-column-center-text t)
  :hook (org-mode . visual-fill-column-mode))
#+end_src



** DONE Workspace
Part of the ~ui: workspaces~ modules. powered by ~persp-mode~

- When persp-mode is active, ~doom-buffer-list~ beconmes workspace-restricted.
- Save and load workspace.

  |---------------------+-------------------------------------------|
  | Keybind             | Description                               |
  |---------------------+-------------------------------------------|
  | SPC TAB n           | Create a new workspace                    |
  | SPC TAB TAB         | Display open workspaces                   |
  | SPC TAB l           | Load a workspace into the current session |
  | SPC TAB R           | Restore last session                      |
  | SPC TAB r           | Rename the current workspace              |
  | SPC TAB .           | Switch to an open workspace               |
  | SPC TAB [ / [w / gT | Switch to previous workspace              |
  | SPC TAB ] / ]w / gt | Switch to next workspace                  |
  | SPC TAB d           | Delete the current workspace              |
  | SPC TAB x           | Clears the curent session                 |
  | SPC TAB 1~9 / M-1~9 | Switch to nth workspace                   |
  | SPC TAB 0 / M-0     | Switch to final workspace                 |
  |---------------------+-------------------------------------------|

기본 Doom Emacs에는 상단 탭에 workspace를 보여주지 못한다. 따라서 =:ui workspace(persp-mode)=​와 기본 emacs 기능인 =tab-bar-mode=​를 활용하여, 상단에 워크스페이스 목록을 탭 형태로 보여주게 만들었다. 필요하면 중간 정렬, 색상 등을 바꿀 수 있다.

#+begin_src emacs-lisp
;; (after! persp-mode
;;   ;; 탭 출력 함수: 왼쪽 정렬 + "none" 제거 + 스타일 지정
;;   (defun workspaces-formatted ()
;;     (let* ((names (remove "none" (or persp-names-cache nil)))
;;            (current-name (safe-persp-name (get-current-persp))))
;;       (concat
;;        " "
;;        (mapconcat
;;         (lambda (name)
;;           (let ((face (if (equal name current-name)
;;                           'my/workspace-tab-selected-face
;;                         'my/workspace-tab-face)))
;;             (propertize (format "   %s   " name) 'face face)))
;;         names
;;         ""))))  ;; 왼쪽 정렬: 구분자 없이 이어 붙임

;;   ;; 강제 redraw를 위한 invisible 트릭
;;   (defun hy/invisible-current-workspace ()
;;     (propertize (safe-persp-name (get-current-persp)) 'invisible t))

;;   ;; tab-bar에 탭 출력 형식 설정
;;   (customize-set-variable
;;    'tab-bar-format
;;    '(workspaces-formatted tab-bar-format-align-right hy/invisible-current-workspace))

;;   ;; 메시지 출력 억제
;;   (advice-add #'+workspace/display :override #'ignore)
;;   (advice-add #'+workspace-message :override #'ignore)

;;   ;; 탭 스타일 설정
;;   (defface my/workspace-tab-face
;;     '((t (:background "#1e1e2e" :foreground "#cdd6f4" :weight normal :box (:line-width -1 :color "#1e1e2e"))))
;;     "Face for inactive workspace tab.")

;;   (defface my/workspace-tab-selected-face
;;     '((t (:background "#f38ba8" :foreground "#1e1e2e" :weight bold :box (:line-width -1 :color "#f38ba8"))))
;;     "Face for active workspace tab."))

;; (run-at-time nil nil (lambda () (tab-bar-mode 1)))
#+end_src

* Copilot
나는 Copilot를 사용하고 있다.
[[https://github.com/chep/copilot-chat.el][chep/copilot-chat.el]]
[[https://github.com/copilot-emacs/copilot.el][copilot-emacs/copilot.el]]

#+begin_src emacs-lisp
;; ':i'를 명시하지 않으면 제대로 작동하지 않음. corfu완 연관있음. courfu README에 설명이 있음.
(map! :desc "Accept completion"         :i "M-TAB" #'copilot-accept-completion)

(map! :prefix ("M-c" . "copilot")
      :desc "Enable Copilot Mode"       :nig "c" #'copilot-mode
      :desc "Accept completion by word" :i   "w" #'coplilot-accept-completion-by-word
      :desc "Next completion"           :i   "n" #'copilot-next-completion
      :desc "Previous completion"       :i   "p" #'copilot-previous-completion
      ;; Copilot Chat
      :desc "Display Chat Window"    "d" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-display)) ;; TODO add toggle
      :desc "Explain Selected Code"  "e" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-explain))
      :desc "Review Selected Code"   "r" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-review))
      :desc "Review whole buffer"    "R" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-review-whole-buffer))
      :desc "Fix Selected Code"      "f" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-fix))
      :desc "Optimize Selected Code" "o" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-optimize))
      :desc "Write Test for Code"    "t" (cmd! (+evil/window-vsplit-and-follow) (copilot-chat-test))
      :desc "Add Current Buffer"     "a" #'copilot-chat-add-current-buffer
      :desc "Remove Current Buffer"  "A" #'copilot-chat-del-current-buffer
      :desc "Open buffer list"       "l" #'copilot-chat-list
      :desc "Document Selected Code" "D" #'copilot-chat-doc
      :desc "Clear Chat History"     "C" #'copilot-chat-reset
      :desc "Insert commit message"  "m" #'copilot-chat-insert-commit-message)
#+end_src

you can use copilot to generate commit message. This is useful when you are not sure what to write in the commit message.

#+begin_src emacs-lisp
;; (add-hook 'git-commit-setup-hook 'copilot-chat-insert-commit-message) # NOTE: not use now
#+end_src

- [ ] Cursor Jump to End of Line When Typing, If you are using whitespace-mode, make sure to remove newline-mark from whitespace-style. # 만약 사용한다면
- [ ] Add a hook to automatically enable copilot-mode in programming modes.
- [ ] 한글 입력시 Copilot 기본 보기에 의해 숨겨짐.

* Files/Dirvish
Dirvish is an improved version of the Emacs inbulit package Dired.

- 사이드바 형식의 파일 관리자
- ranger 스타일 파일 관리자
- 프리뷰 기능

general-override-mode-map
doom-leader-map
파일 관련 키 바인딩은 전부 f로 통일한다.

| Keybind | Description             |
|---------+-------------------------|
| <L> SPC | Toggle project side bar |
| <L>-f f | Open file browser       |
| <L>-f c | Open doom directory     |
| <L>-f d | Open config directory   |
| <L>-f e | Open emacs directory    |
| <L>-f m | Open modules directory  |

#+begin_src emacs-lisp
(remove-key-bindings 'doom-leader-map '("o /" "f p" "."))
;; (remove-key-bindings 'doom-leader-open-map '("/"))
(remove-key-bindings 'doom-leader-file-map '("E" "F" "P" "U" "Y" "c" "d" "e" "f" "h" "l" "p" "u" "m"))

(map! :leader
      :desc "Project sidebar"   :ng "<SPC>" #'dirvish-side
      :prefix ("f" . "file")
      :desc "File browser"      :ng "f" #'dirvish
      :desc "Config directory"  :ng "c" (cmd! (dirvish my/config-dir))
      :desc "Doom directory"    :ng "d" (cmd! (dirvish doom-user-dir))
      :desc "Emacs directory"   :ng "e" (cmd! (dirvish my/emacs-dir))
      :desc "Modules directory" :ng "m" (cmd! (dirvish my/emacs-modules-dir))
      :desc "Modules directory" :ng "w" (cmd! (dirvish my/wiki-dir)))
#+end_src

dirvish-side는 dired로 dirvish와는 다르게 작동하는 것 같다. 이를 동일한 매핑으로 유지하려면 다음를 추가해야 한다. dirvish와 dirvish-side의 매핑이 동일하게 유지된다.
#+begin_src emacs-lisp
;; (dirvish-override-dired-mode)
#+end_src

dirvish 파일에서 사용하는 키 바인딩들이다.

#+begin_src emacs-lisp
(defun dt/close-dirvish-side ()
  "Close Dirvish side bar if it exist."
  (let ((visible (dirvish-side--session-visible-p)))
    (when (window-live-p visible)
      (delete-window visible))))

(after! dired
  ;; (setq dired-mode-map (make-sparse-keymap))
  (remove-key-bindings 'dired-mode-map
                       '("C-x" ",h" "*(" "*." "*O" "M-b" "M-e" "M-f" "M-m" "M-n" "M-s" ))
  (map! :map dired-mode-map
        :ng "k" #'dired-previous-line
        :ng "j" #'dired-next-line
        :ng "RET" #'dired-find-file

        :ng "," #'dired-create-directory
        :ng "." #'dired-create-empty-file
        :ng "d" #'dired-do-delete
        :ng "r" #'dired-do-rename

        :ng "[[" #'dired-prev-dirline
        :ng "]]" #'dired-next-dirline)

  (advice-add 'dired-find-file :after #'dt/close-dirvish-side)
  )

#+end_src



| Keybind | Description         |
|---------+---------------------|
| ?       | Dispatch            |
| q       | Quit dirvish        |
| b       | Quick access        |
| p       | yank '바꿔야함'      |
| S       | Quick sort          |
| F       | Layout toggle       |
| h       | Up directory        |
| l       | Find files          |
| TAB     | Toggle subtree      |
| M s     | Setup menu          |
| y l     | Copy file ture path |
| y n     | Copy file name      |
| y p     | Copy file path      |
| Y r     | Copy remote path    |
| y y     | Copy                |
| s s     | symlink             |
| s S     | relative synlink    |
| s h     | hardlink            |

파일 관련 키 바인딩

| Keybind | Description       |
|---------+-------------------|
| <L>-f C | Copy this file    |
| <L>-f D | Delete this file  |
| <L>-f M | Move this file    |
| <L>-f S | Write this file   |
| <L>-f r | Recent open files |
| <L>-f y | Yank buffer path  |

#+begin_src emacs-lisp
(map! :leader
      :prefix ("f")
      :desc "Write this file" :ng "s" #'write-file
      :desc "Move this file"  :ng "M" #'doom-move-this-file)
#+end_src

#+begin_src emacs-lisp
(setq-default delete-by-moving-to-trash t) ; Delete files to trash
#+end_src

** Open Specific Files
The format I use for these bindings is ~SPC =~ plus key since Doom Emacs does not use ~SPC =~.

=NOTE=: Doom Emacs already has a function ~doom/open-private-config~ set to the keybinding ~SPC f p~. you can open file in your ~HOME/.config/doom~ directory. But this need to search file name to open file, I don't want to typing more, so i use own key binding for open files.

| KEYBINDING | DESCRIPTION               | PATH TO FILE                                             |
|------------+---------------------------+----------------------------------------------------------|
| SPC = c    | Open doom config.org      | ~/.config/doom/config.org                                |
| SPC = i    | Open doom init.el         | ~/.config/doom/init.el                                   |
| SPC = p    | Open doom packages.el     | ~/.config/doom/packages.el                               |
| SPC = a    | Open agenda file          | ~/Org/agenda.org                                         |
| SPC = =    | Open dashboard file       | ~/.config/doom/dashboard.org                             |
| SPC = m    | Open doom module README   | ~/.config/emacs/modules/README.org                       |
| SPC = E    | Open evil file            | ~/.config/emacs/modules/editor/evil/config.el            |
| SPC = d    | Open defaults file        | ~/.config/emacs/modules/config/default/+evil-bindings.el |
| SPC = e e  | Open emacs modules folder | ~/.config/emacs/moudules                                 |
| SPC = e a  | Open eshell aliases       | ~/.config/doom/eshell/aliases                            |
| SPC = e p  | Open eshell profile       | ~/.config/doom/eshell/profile                            |
|            |                           |                                                          |

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("=" . "open file")
       :desc "Open doom config.org"    "c" #'(lambda () (interactive) (find-file "~/.config/doom/config.org"))
       :desc "Open doom init.org"      "i" #'(lambda () (interactive) (find-file "~/.config/doom/init.el"))
       :desc "Open doom package.org"   "p" #'(lambda () (interactive) (find-file "~/.config/doom/packages.el"))
       :desc "Open doom agenda.org"    "a" #'(lambda () (interactive) (find-file "~/Org/agenda.org"))
       :desc "Open dashboard file"     "=" #'(lambda () (interactive) (find-file "~/.config/doom/dashboard.org"))
       :desc "Open doom module README" "m" #'(lambda () (interactive) (find-file
       "~/.config/emacs/modules/README.org"))
       :desc "Open evil file"          "E" #'(lambda () (interactive) (find-file
       "~/.config/emacs/modules/editor/evil/config.el"))
       :desc "Open default file"       "d" #'(lambda () (interactive) (find-file
       "~/.config/emacs/modules/config/default/+evil-bindings.el"))))

(map! :leader
      (:prefix ("= e" . "open shell files")
       :desc "Open emacs modules folder" "e" #'(lambda () (interactive) (find-file "~/.config/emacs/moudules"))
       :desc "Open eshell aliases"       "a" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/aliases"))
       :desc "Open eshell profile"       "p" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/profile"))))

#+end_src

* Autocompletion
** Code Autocompletion
Doom Emacs의 Autocompletion은 *corfu*를 사용한다.

다음의 사이트를 참고하여 설정하자.
[[https://github.com/minad/corfu][corfu-Github]]
[[https://github.com/minad/cape][cape-Github]]

약어를 설정하면 약어만 나오는 문제가 있음.

| Keybind    | Evil      | Description           |
|------------+-----------+-----------------------|
| C-n, TAB   | [I] C-j   | Next condidate        |
| C-p  S-TAB | [I] C-k   | Previous condidate    |
|            | [I] C-d   | Scroll up candidate   |
|            | [I] C-u   | Scroll down candidate |
| C-S-n      | [I] C-S-j | Scroll down doc line  |
| C-S-p      | [I] C-S-k | Scroll up doc line    |
| M-g        |           | Show location         |
| M-/        |           | Completion dabbrev    |
| C-M-/      |           | Completion dabbrev    |
|            |           |                       |

#+begin_src emacs-lisp
(setq corfu-auto-delay 0.1
      corfu-count 8
      +corfu-want-minibuffer-completion nil)
#+end_src

** Searching with muliple keywords
If the /+orderless/ flag is enabled, completion performs with multiple search keywords by use of space as the separator. Pressing ~C SPC~ while completing, inserts a space as separator. this allows searching with space-separeted terms; each piece will match individually and in any order, with smart casing. Pressing just ~SPC~ acts as noremal and quits completion
[[https://github.com/oantolin/orderless#company][orderless-Github]]

| Keybind | Evil      | Description                   |
|---------+-----------+-------------------------------|
| M-SPC   | [I] C-SPC | Insert separator              |
| SPC     |           | (when completing) Self-insert |

# - [[var:completion-at-point-functions]] ::
#   This is not a module/package variable, but a builtin Emacs one. Even so, it's
#   very important to how Corfu works, so we document it here. It contains a list
#   of functions that are called in turn to generate completion candidates. The
#   regular (non-lexical) value should contain few entries and they should
#   generally be context aware, so as to predict what you need. Additional
#   functions can be added as you get into more and more specific contexts. Also,
#   there may be cases where you know beforehand the kind of candidate needed, and
#   want to enable only that one. For this, the variable may be lexically bound to
#   the correct value, or you may call the CAPF interactively if a single function
#   is all you need.

# ** Adding CAPFs to a mode
# To add other CAPFs on a mode-per-mode basis, put either of the following in your
# ~config.el~:

# #+begin_src emacs-lisp
# (add-hook! some-mode (add-hook 'completion-at-point-functions #'some-capf depth t))
# ;; OR, but note the different call signature
# (add-hook 'some-mode-hook (lambda () (add-hook 'completion-at-point-functions #'some-capf depth t)))
# #+end_src

# ~DEPTH~ above is an integer between -100, 100, and defaults to 0 if nil. Also
# see ~add-hook!~'s documentation for additional ways to call it. ~add-hook~ only
# accepts the quoted arguments form above.

# ** Adding CAPFs to a key
# To add other CAPFs to keys, adapt the snippet below into your ~config.el~:

# #+begin_src emacs-lisp
# (map! :map some-mode-map
#       "C-x e" #'cape-emoji)
# #+end_src

# It's okay to add to the mode directly because ~completion-at-point~ works
# regardless of Corfu (the latter is an enhanced UI for the former). Just note not
# all CAPFs are interactive to be called this way, in which case you can use
# [[doom-package:cape]]'s adapter to enable this.

** Snippet
For the snippet package doom use *Yasnippet*. yasnippet allows you to insert some pre-made code by typing a few characters.

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("s" . "snippets")
       ; TODO 생성된 스니펫 종료시 버퍼가 남음
       :desc "New snippet"         :n "s" (cmd! (+evil/window-split-and-follow)
                                                (yas-new-snippet))
       :desc "Open snippet file"   :n "o" (cmd! (+evil/window-split-and-follow)
                                                (yas-visit-snippet-file))
       :desc "Reload snippet"      :n "r" #'yas-reload-all
       :desc "Show active snippet" :n "a" #'yas-describe-tables
       :desc "Open YASnippet doc"  :n "?" (cmd! (evil-window-split)
                                                (evil-window-move-far-right)
                                                (find-file "~/.config/emacs/.local/straight/repos/yasnippet/doc/index.org"))))

(after! yasnippet
  (map! :map snippet-mode-map
        :localleader
        :desc "Load snippet buffer" :n "l" #'yas-load-snippet-buffer
        :desc "Tryout snippet"      :n "t" #'yas-tryout-snippet)
  ;; Delete default key mapping
  (define-key snippet-mode-map (kbd "C-c C-k") nil)
  (define-key snippet-mode-map (kbd "C-c C-l") nil)
  (define-key snippet-mode-map (kbd "C-c C-t") nil))
#+end_src


Yasnippet에 자동 확장 기능을 따로 지원하지 않아서 다음 사이트에서 참고하여 구현을 했다. [[https://github.com/joaotavora/yasnippet/issues/998][expand with no trigger key-github]]

Add ~# condition: 'auto~ in the snippets to expand.

#+begin_src emacs-lisp
(defun dt/yas-expanding-auto-snippets ()
  (when (and (boundp 'yas-minor-mode) yas-minor-mode)
    (let ((yas-buffer-local-condition ''(require-snippet-condition . auto)))
      (yas-expand))))
(add-hook 'post-command-hook #'dt/yas-expanding-auto-snippets)
#+end_src

* DONE hl-TODO
Part of the ~ui: hl-todo~ modules.
By enabling this module, the following keywords will be highlighted if they occur in code comments:

- ~TODO~: For things that need to be done.
- ~REVIEW~: For things that were done hastily and/or hasn't been thoroughly tested. it may not even be necessary!
- ~SOMEDAY~: For things that could be implemented in the future but is not a current priority.
- ~HACK~: For a quick or temporary workaround that is not ideal and needs proper implementation later.
- ~DEPRECATED~: A feature or piece of code that is no longer recommended for use and may be removed in the future.
- ~ENHANCE~: For a things that could be improved or made more efficint in the future.
- ~NOTE~: For a things that Provides additional information or context
- ~FIXME~: For problems that will become bigger problems later if not fixed ASAP.
- ~BUG~: For a known bug that needs a workaround.
- ~DONE~: For a things that has been completed
- ~UNUSED~: For a things that don't used.

기존에 있던 설정 지우고 새로 설정했다.

#+begin_src emacs-lisp
;; in $DOOMDIR/config.el
(after! hl-todo
  (setq hl-todo-keyword-faces
        '(
          ("TODO" warning bold)
          ("REVIEW" font-lock-keyword-face bold)
          ("SOMEDAY" font-lock-keyword-face bold)
          ("HACK" font-lock-constant-face bold)
          ("DEPRECATED" font-lock-constant-face bold)
          ("ENHANCE" font-lock-constat-face bold)
          ("NOTE" success bold)
          ("FIXME" error bold)
          ("BUG" error bold)
          ("DONE" font-lock-operator-face bold)
          ("UNKNOWN" font-lock-operator-face bold)
          ("UNUSED" success bold)
        )))
#+end_src

| Keybind | Description                           |
|---------+---------------------------------------|
| [t      | Go to next highlight item             |
| ]t      | Go to previous highlight item         |


* Org Mode

I use Org for:
1. Tasks manage with Org-agenda
2. Blogging
3. Setting my wiki with org-roam
4. Literate programming with babel (and emacs-jupyter)
5. Managing references + PDFs with Org-ref
6. Annotating PDFs with notes via org-noter
7. Personal wiki with Org-roam

~C-c~ 키를 다른 용도로 사용하기 때문에 Org-mode에서 ~C-c~​를 prefix키로 사용하는 모든 키를 제거하였다.

#+begin_src emacs-lisp
(map! :map org-mode-map
      "C-c" nil)
#+end_src

#+begin_src emacs-lisp
(setq org-directory my/wiki-dir)
#+end_src

Easier to create a new empty Org buffer or open a specific Org file.

#+begin_src emacs-lisp
(evil-define-command my/+evil-buffer-org-new (_count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)
        (setq-local doom-real-buffer-p t)))))

(map! :leader
      (:prefix "b"
       :desc "New empty Org buffer" "o" #'my/+evil-buffer-org-new))
#+end_src



** Org Content
*** Basic Markup

Add ~org-modern-mod~ to the Org mode hooks

#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)
(add-hook 'org-mode-hook #'org-appear-mode)

(setq org-table-plain-columns t)

#+end_src


*Basic keymap*

예시
    - =>>= to promote a heading
    - =>ar= to promote a tree
    - =<(= to swap a table column with the one on the left
    - =vie2>= to move a table column two places to the right

# TODO element 내비게이션 바꾸기


|---------+------------------------------|
| key     | explanation                  |
|---------+------------------------------|
| gh      | parent of element            |
| gj / gk | Next / Previous element      |
| gl      | first subelement             |
| gH      | top-level heading            |
| > / <   | Promote / demote marked area |
|---------+------------------------------|

|---------+--------------------------+----------------------------------|
| key     | function                 | examples                         |
|---------+--------------------------+----------------------------------|
| ae / ie | an/inner object          | link, markup, table cell         |
| aE / iE | an/inner element         | paragraph, code block, table row |
| ar / ir | an/inner greater-element | item list, table                 |
| aR / iR | an/inner subtree         | subtree starting with a header   |
|---------+--------------------------+----------------------------------|
  Examples:
   - =vae= to select a paragraph

   - =daR= to delete a subtree
   - =yiR= to yank the contents of a subtree

*Header*

Insert heading at point, not after the current subtree.

#+begin_src emacs-lisp
(after! org
  (setq org-insert-heading-respect-content nil ;; Non-nil means insert new headings after the current subtree.
        org-startup-indented nil
        org-indent-indentation-per-level 2)

  (custom-set-faces
  '(org-document-title ((t (:inherit default :weight bold :foreground "#f380ac" :height 1.5 :underline nil))))
  '(org-level-1 ((t (:inherit default :weight bold :foreground "#f380ac" :height 1.3))))
  '(org-level-2 ((t (:inherit default :weight bold :foreground "#f9e2af" :height 1.3))))
  '(org-level-3 ((t (:inherit default :weight bold :foreground "#89b4fa" :height 1.3))))
  '(org-level-4 ((t (:inherit default :weight bold :foreground "#a6e3a1" :height 1.3))))
  '(org-level-5 ((t (:inherit default :weight bold :foreground "white"))))
  '(org-level-6 ((t (:inherit default :weight bold :foreground "white"))))
  '(org-level-7 ((t (:inherit default :weight bold :foreground "white"))))
  '(org-level-8 ((t (:inherit default :weight bold :foreground "white"))))))

(setq org-modern-fold-stars '(("*" . "*") ("**" . "**") ("***" . "***") ("****" . "****")))
;; (setq org-ellipsis "⋯") ; FIXME
#+end_src


|--------------+------------------------|
| key          | explanation            |
|--------------+------------------------|
| M-ret        | insert heading         |
| <tab>, g TAB | fold / unfold headings |
| M-h or <<    | promote a heading      |
| M-l or >>    | demote a heading       |
| M-H or <aR   | promote a subtree      |
| M-L or >aR   | demote a subtree       |
| M-k          | move subtree up        |
| M-j          | move subtree down      |
| M-K          | Move heading up        |
| M-J          | Mvoe heading down      |
|--------------+------------------------|
*Paragraphs and Sentence*


*Emphasis*
단어를 강조할 수 있는 여러 방법이 있다. *bold*, /italic/, _underlined_, =verbatim=, ~inlineCode~ 그리고 +strike-through+ 의 방법이 있다.


Org 문서를 읽을 때 강조 기호가 생기면 읽기 불편하기 때문에, 강조 기호를 숨기기로 한다.

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
(setq org-appear-autoemphasis t)
;; org-appear-autosubmarkers t) ;; toggle Subscript, superscript markers
;; org-appear-autolinks

;; 변경 사항을 Org-mode에 적용
;; (with-eval-after-load 'org
;;   (org-element-update-syntax))

;; Emphasis 색상은 사용하는 테마와 충돌할 수 있다. 따라서 테마 로드 이후 강조 색상을 재정의한다. (gpt)
;; :foreground "blue" 다음의 설정으로 색상 변경 가능.
(setq org-emphasis-alist
      '(("*" (org-emphasis-bold (:weight ultra-bold)))
        ("/" (org-emphasis-italic (:slant italic)))
        ("_" (org-emphasis-underline (:underline t)))
        ("-" (org-emphasis-strikethrough (:strike-through t)))
        ("=" (org-verbatim (:foreground "#a6e3a1" :background "#181825")))
        ("~" (org-code (:foreground "#a6e3a1" :background "#181825")))))
#+end_src
:foreground "#a6e3a1"

*Zero-with spaces*
Org 문서로 한글 작업을 할 경우 emphasis할 때, 글자 중간에 강조를 해야 할 때가 있다. 예를 들면 *다음*과 같다. 강조를 제대로 하기 위해 zero-width space를 기호와 바로 뒤의 문자에 삽입하면 강조가 제대로 표시된다.

Org-mode에서는 Zero-idth space가 기본적으로 숨겨진다. 그리고 ~C-c Z~를 눌러 Zero-width space를 빨간색 배경으로 강조하여 확인할 수 있다.

#+begin_src emacs-lisp
(map! :map org-mode-map
      :nie "M-\\" (cmd! (insert "\u200B")))

;; 숨기기 설정
(defun my-hide-zero-width-chars ()
  "Make ZERO WIDTH SPACE (U+200B) invisible in this buffer."
  (setq-local glyphless-char-display
              (let ((table (copy-sequence glyphless-char-display)))
                (set-char-table-range table (char-from-name "ZERO WIDTH SPACE") 'zero-width)
                table)))

;; 강조 설정
(defun my-highlight-zero-width-chars ()
  "Highlight ZERO WIDTH SPACE (U+200B) globally with a red background."
  (setq-local glyphless-char-display
              (let ((table (copy-sequence glyphless-char-display)))
                (set-char-table-range table (char-from-name "ZERO WIDTH SPACE") 'thin-space)
                table))
  (set-face-attribute 'glyphless-char nil
                      :background "red"
                      :foreground nil))

;; 강조 토글
(defun my-toggle-zero-width-chars-visibility ()
  "Toggle visibility of ZERO WIDTH SPACE (U+200B)."
  (interactive)
  (let ((current-display (char-table-range glyphless-char-display (char-from-name "ZERO WIDTH SPACE"))))
    (if (eq current-display 'zero-width)
        (my-highlight-zero-width-chars)
      (my-hide-zero-width-chars))))

;; 키 바인딩
(map! :map org-mode-map
      :nie "C-c z" #'my-toggle-zero-width-chars-visibility)

;; Org-mode에서 숨기기 기본 적용
(add-hook 'org-mode-hook #'my-hide-zero-width-chars)
#+end_src



*Strip zero width spaces*
Zero width spaces are handy as a semantic separator, but not something we want passed through to the exports.
- [ ] put this in to export
다음을 참고하자. https://tecosaur.github.io/emacs-config/#strip-zero-width
#+begin_src emacs-lisp
;; (defun +org-export-remove-zero-width-space (text _backend _info)
;;   "Remove zero width spaces from TEXT."
;;   (unless (org-export-derived-backend-p 'org)
;;     (replace-regexp-in-string "\u200B" "" text)))

;; (add-to-list 'org-export-filter-final-output-functions #'+org-export-remove-zero-width-space t)
#+end_src


*Subscripts and Superscripts*
Subscripts와 Superscripts는 '^'와 '_'를 사용해서 표시할 수 있다.

*List*

#+begin_src emacs-lisp
(setq org-modern-list '((43 . "+")   ; For "+"
                        (45 . "•")   ; For "-"
                        (42 . "➤"))) ; For "*"
#+end_src

#+begin_src emacs-lisp
(after! org
  (setq org-list-allow-alphabetical t ))
#+end_src



*Special Symbols*
LaTeX syntax로 특수 문자를 사용할 수 있다. 이를 entities라고 한다. 'org-entities-help'를 사용해서

*Images*
You can embed images in Org-mode using file links, both absolute and relative paths are supproted.:
~[[/path/to/image.png]]~

#+begin_src emacs-lisp
(setq org-startup-with-inline-images t) ; Enable inlnie image preview at startup
#+end_src

This can also be configured on a per-file basis by adding one of the following lines anywhere in the buffer:
~#+STARTUP: inlineimages~
~#+STARTUP: noinlineimages~

You can adjusting image size and alignment using attributes:

#+begin_src
#+ATTR_ORG :width 300px :align center
[[file:image.png]]
#+end_src

~:width~, Specifies image width in pixels.
~:align~, Aligns the image to the left, center, or right.

*Horizontal Rules*
A line consisting of only dashes, and at least 5 of  them, is exported as a horizontal line.

*Footnotes*

#+begin_src
This is some text with a footnote.[fn:1]
You can yse named footnotes.[fn:NAME]
An foontnote where the definition is given directly at the reference point.[fn:: This is the inline definition of this footnote]
An inline definition of a footnote, which also specifies a name for the note.[fn:NAME: a definition]
...
[fn:1] This is the content of the footnote.
[fn:NAME] This is the content of the named footnote.
#+end_src


| Keybind   | Description                               |
|-----------+-------------------------------------------|
| C-c C-x f | The footnote action command               |
| C-c C-c   | Jump to footnote reference or definition. |


- *Checkbox*
  체크박스는 위계가 있다. 자식 Checkbox가 모두 채워지면 부모 체크박스는 자동으로 채워진다. 이때 부모 체크박스는 자식 체크박스가 전부 체크되기 전에는 체크할 수 없다.
  자식 체크박스가 있을 경우, 부모 체크박스 뒤에 ~[/]~ 또는 ~[%]~ 를 추가하면 체크된 항목에 대한 정보가 표시된다.

| KEYBIDING | Evil    | DESCRIPTION                          |
|-----------+---------+--------------------------------------|
| C-c C-c   | SPC [N] | Toggle checkbox                      |
| C-SPC     |         | Inserts a checkbox at the same level |


*Table*

~org-modern~를 사용해서 테이블의 가로와 세로의 길이를 조절하여 똑같이 맞추었다.

#+begin_src emacs-lisp
(setq org-modern-table-vertical 1
      org-modern-table-horizontal 0.2)
#+end_src



|------------+--------------------------------|
| key        | explanation                    |
|------------+--------------------------------|
| TAB, S-TAB | Next / Previous cell           |
| RET        | Change cell content            |
| ( / )      | Previous / Next table cell     |
| { / }      | Beginning / End of table       |
| M-h / M-l  | Move table column left / right |
| M-k / M-j  | Move table column up / down    |
| M-H / M-L  | Delete / Insert column         |
| M-K / M-J  | Delete / Insert row            |
|------------+--------------------------------|

| vae       | select table cell              |
| vaE       | select table row               |
| var       | select whole table             |

| KEYBIDING   | DESCRIPTION         |
|-------------+---------------------|
| M-h/j/k/l   | Move table column   |
| C-S-h/j/k/l | Move cell           |
| o, O        | Insert columu       |
|             |                     |


*** Hyperlinks
*** Todo Items

유니코드 이모지가 제대로 렌더링 되지 않아서 nerd font icon를 사용했다.
#+begin_src emacs-lisp
(setq org-modern-priority (quote ((?A . "󰬈") (?B . "󰬉") (?C . "󰬊"))))
      ;; org-modern-priority-faces)

(setq org-modern-progress 10 ;; Width in characters to draw progress bars
      org-modern-progress-complete '(t :background "#1e1e2e" :foreground "#a6e3a1")
      org-modern-progress-incomplete '(t :background "#313244" :foreground "#585b70"))

#+end_src

#+begin_src emacs-lisp
;; (after! org
;;   (setq org-todo-keywords
;;         '((sequence "TODO(t)" "INPROG(i)" "PROJ(p)" "STORY(s)" "WAIT(w@/!)" "|" "DONE(d@/!)" "KILL(k@/!)")
;;           (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)"))
;;         ;; The triggers break down to the following rules:

;;         ;; - Moving a task to =KILLED= adds a =killed= tag
;;         ;; - Moving a task to =WAIT= adds a =waiting= tag
;;         ;; - Moving a task to a done state removes =WAIT= and =HOLD= tags
;;         ;; - Moving a task to =TODO= removes all tags
;;         ;; - Moving a task to =NEXT= removes all tags
;;         ;; - Moving a task to =DONE= removes all tags
;;         org-todo-state-tags-triggers
;;         '(("KILL" ("killed" . t))
;;           ("HOLD" ("hold" . t))
;;           ("WAIT" ("waiting" . t))
;;           (done ("waiting") ("hold"))
;;           ("TODO" ("waiting") ("cancelled") ("hold"))
;;           ("NEXT" ("waiting") ("cancelled") ("hold"))
;;           ("DONE" ("waiting") ("cancelled") ("hold")))

;;         ;; This settings allows to fixup the state of a todo item without
;;         ;; triggering notes or log.
;;         org-treat-S-cursor-todo-selection-as-state-change nil))
#+end_src


*** Tags
*** Capture and Attachments
*Capture*
Capture lets you quickly store notes with little interruption of your work flow.
캡쳐는 미리 정의된 템플릿을 사용하여 특정 파일과 위치에 체계적으로 내용을 추가한다.

1. Keys: The keys that will select the template, can use two keys like ~bt~.
2. Descrioption: A short string desccribing the template.
3. Type: The type of entry.
   - entry, an org node ~"* %?"~
   - item, a plain list item ~"- %?"~
   - checkitem, a checkbox item. ~"- [ ] %?"~
   - table-line, a new line in the fisrt table. ~"| %? |"~
   - plain, text to be inserted as it is.
4. Target, Specification of where the captured item should be placed.
내용(Content):
        저장될 항목의 서식입니다.
        동적으로 값을 생성하는 포맷 옵션:
        %?: 커서의 초기 위치.
        %i: 선택한 텍스트(있으면 삽입).
        %U: 현재 날짜와 시간(ISO 형식).
        %T: 현재 날짜와 시간(일반 형식).
        %a: 원본 링크.
        %F: 파일 이름.
        %:keyword: 원본 관련 메타데이터(예: 제목, 작성자 등).
다음을 참고해서 템플릿을 만들 것. https://orgmode.org/manual/Capture-templates.html
#+begin_src emacs-lisp
(map! :desc "Org Capture" "C-c c" #'org-capture)

(setq org-default-notes-file (expand-file-name "capture.org" org-directory))

;; TODO 템플릿 추가하기.
(setq org-capture-templates
      '(("t" "Todo" entry
         (file+headline +org-capture-todo-file "Inbox")
         "* [ ] %?\n%i\n%a" :prepend t)))
 ;; ("n" "Personal notes" entry
;;   (file+headline +org-capture-notes-file "Inbox")
;;   "* %u %?\n%i\n%a" :prepend t)
;;  ("j" "Journal" entry
;;   (file+olp+datetree +org-capture-journal-file)
;;   "* %U %?\n%i\n%a" :prepend t)
;;  ("p" "Templates for projects")
;;  ("pt" "Project-local todo" entry
;;   (file+headline +org-capture-project-todo-file "Inbox")
;;   "* TODO %?\n%i\n%a" :prepend t)
;;  ("pn" "Project-local notes" entry
;;   (file+headline +org-capture-project-notes-file "Inbox")
;;   "* %U %?\n%i\n%a" :prepend t)
;;  ("pc" "Project-local changelog" entry
;;   (file+headline +org-capture-project-changelog-file "Unreleased")
;;   "* %U %?\n%i\n%a" :prepend t)
;;  ("o" "Centralized templates for projects")
;;  ("ot" "Project todo" entry #'+org-capture-central-project-todo-file "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
;;  ("on" "Project notes" entry #'+org-capture-central-project-notes-file "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
;;  ("oc" "Project changelog" entry #'+org-capture-central-project-changelog-file "* %U %?\n %i\n %a" :heading "Changelog" :prepend t))

#+end_src

| Keybind | Description                                               |
|---------+-----------------------------------------------------------|
| C-c a   | Display the capture templates menu                        |
| C-c C-c | returns to before the capture process                     |
| C-c C-k | Kill the capture process and retrun to the previous state |
| C-c C-w | refiling the note to a differnt place.                    |

*Attachments*
https://orgmode.org/manual/Attachments.html

*** 커스텀 Timestamp
기본 Timestamp에 요일이 포함되어 있는 것이 마음에 들지 않아서 날짜 형식을 바꾸기로 했다.

#+begin_src emacs-lisp
(setq org-time-stamp-custom-formats '("<%Y-%m-%d>" . "<%Y-%m-%d %H:%M")
      org-display-custom-times t)
#+end_src

*** DEADLINE 작업 설정
기본적으로 마감일 전 3일 전에 경고를 표시하도록 한다.

#+begin_src emacs-lisp
(setq org-deadline-warning-days 3)
#+end_src

*** Clocking

#+begin_src emacs-lisp
;; (org-clock-auto-clockout-insinuate) ;; When idle automatically clock-out

(setq org-clock-out-when-done t
      org-clock-continuously t
      org-clock-auto-clockout-timer 300 ;; 5분 Idle 시 Clock-out
      org-clock-idle-time 10)

#+end_src

*** Archive


#+begin_src emacs-lisp
;; (setq org-archive-location "~/org.archive.org::") ;; "%s_archive::"로 해당 파일의 특정 섹션에 추가할 수 있다.
;; (setq org-agenda-skip-archived-trees t) ;; Archive된 항목을 Agenda에서 제외/


#+end_src






** Org-ol-tree

Display all headlines as an outline tree on the right side of the frame. You can press ~ENT~ to scroll buffer to the selected heading,

#+begin_src emacs-lisp
;; (use-package! org-ol-tree
;;   :commands org-ol-tree
;;   :config
  ;; (setq org-ol-tree-ui-icon-set
  ;;       (if (and (display-graphic-p)
  ;;                (fboundp 'all-the-icons-material))
  ;;           'all-the-icons
  ;;         'unicode))
  ;; (org-ol-tree-ui--update-icon-set))
;; (setq org-side-tree-persistent t        ; Use a single buffer for all trees
;;       org-side-tree-display-side 'right ; Side of window
;;       org-side-tree-width 30            ; Sets width of side-tree window
;;       org-side-tree-timer-delay .1      ; Timer to update
;;       )

;; (map! :map org-side-tree-mode-map
;;       :desc "Next heading"     :n "j"  #'org-side-tree-next-heading
;;       :desc "Previous heading" :n "k"  #'org-side-tree-previous-heading
;;       :desc ""                 :n "l" #'org-side-tree-next-todo
;;       :desc ""                 :n "h" #'org-side-tree-previous-todo
;;       :desc ""                 :n "K" #'org-side-tree-move-subtree-up
;;       :desc ""                 :n "J" #'org-side-tree-move-subtree-down
;;       :desc ""                 :n "<TAB>" #'org-side-tree-toggle)
#+end_src
**




** Org Agenda

Agenda는 Org Mode에서 작업과 일정 관리를 위한 도구이다. TODO 항목, DEADLINE, SCHEDULED, Timestamp 등으로 모아서 보여주며, 여러 파일에 걸친 작업을 한눈에 확인하고 효율적으로 관리할 수 있다. Agenda로 일별/주간 Agenda(a), TODO 보기(t), 마감일 보기(m), 시간 로그 보기(l), 태그 필터 보기(m) 그리고 사용자가 정의한 custom view를 볼 수 있다. 추출된 정보는 agenda buffer라는 특수한 buffer로 표시된다. 이 buffer는 읽기 전용이므로 편집할 수 없지만, 명령어를 통해서 해당 Org 파일에 들어가서 편집할 수 있다.

주석 처리된 항목이나 아카이브된 항목을 보고서에서 제외한다.

#+begin_src emacs-lisp
(setq org-agenda-skip-comment-trees t
      org-agenda-skip-archived-trees t)
#+end_src

Agenda 버퍼를 어디에 표시할지 설정할 수 있다.

#+begin_src emacs-lisp
(setq org-agenda-window-setup 'other-window    ;; another options: 'current-window'
      org-agenda-restore-windows-after-quit t) ;; Restore windows when the agenda exits
#+end_src

Two variables control how the agenda buffer is displayed and whether the window configuration is restored when the agenda exits: org-agenda-window-setup and org-agenda-restore-windows-after-quit

Agenda는 org-agenda-files 변수에 지정된 파일들을 기반으로 작업, 마감일, 일정 등을 요약하여 보여준다. 파일 경로나 디렉터리를 포함할 수 있다.

Agenda로 관리할 Org 파일들을 설정한다.

#+begin_src emacs-lisp
(setq org-agenda-files (list "~/wiki/inbox.org"
                             "~/wiki/test.org"
                             "~/wiki/agenda.org"))
#+end_src

Org-mode는 현재 버퍼 파일을 ~org-agenda-files~​에 자동으로 추가하는 ~C-c [~​과 ~C-c ]~ 키를 가지고 있는데 이를 사용하면 디렉터리 기반의 설정이 명시적인 파일 목록으로 대체된다. 즉 새로운 ~.org~ 파일이 디렉터리에 추가되어도 Agenda에 포함되지 않는 문제가 발생한다. 따라서 해당 키는 사용하지 않고 설정파일의 ~org-agenda-files~​에 디렉터리와 파일을 직접 추가하는 방식을 하기로 했다.

- [ ] 설명 추가

#+begin_src emacs-lisp
(after! org-agenda
  (org-super-agenda-mode))
#+end_src


#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("i" "Inbox"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
#+end_src







#+begin_src emacs-lisp
;; (after! org-agenda
;;   (setq org-agenda-files (list "~/org/agenda.org"
;;                                "~/org/todo.org"))
;;   (setq org-agenda-window-setup 'current-window
;;         org-agenda-restore-windows-after-quit t
;;         org-agenda-show-all-dates nil
;;         org-agenda-time-in-grid t
;;         org-agenda-show-current-time-in-grid t
;;         org-agenda-start-on-weekday 1
;;         org-agenda-span 7
;;         org-agenda-tags-column  0
;;         org-agenda-block-separator nil
;;         org-agenda-category-icon-alist nil
;;         org-agenda-sticky t)
;;   (setq org-agenda-prefix-format
;;         '((agenda . "%i %?-12t%s")
;;           (todo .   "%i")
;;           (tags .   "%i")
;;           (search . "%i")))
;;   (setq org-agenda-sorting-strategy
;;         '((agenda deadline-down scheduled-down todo-state-up time-up
;;                   habit-down priority-down category-keep)
;;           (todo   priority-down category-keep)
;;           (tags   timestamp-up priority-down category-keep)
;;           (search category-keep))))


;; (after! org
;;   (remove-hook 'org-agenda-finalize-hook '+org-exclude-agenda-buffers-from-workspace-h)
;;   (remove-hook 'org-agenda-finalize-hook
;;                '+org-defer-mode-in-agenda-buffers-h))

;; (after! org
;;   (setq org-agenda-deadline-faces
;;         '((1.0 . error)
;;           (1.0 . org-warning)
;;           (0.5 . org-upcoming-deadline)
;;           (0.0 . org-upcoming-distant-deadline))))
#+end_src




*** Agenda Viws

| KEYBIDING | DESCRIPTION                                             |
|-----------+---------------------------------------------------------|
| SPC-o-A a | Create calendar-like agenda                             |
| SPC-o-A t | Create list of all TODO item                            |
| m         | Create list of headline mathcing a given expression     |
| s         | Create a list of entries selected by keywords or regex. |
| \/        | Search for a regex                                      |
| \#        | Create a list of stuck projects                         |
| \!        | Configure the list of stuck projects                    |
| \*        | Toggle sticky agenda views                              |
|           |                                                         |

**** Todo view


| KEYBIDING | DESCRIPTION             |
|-----------+-------------------------|
| t         | Chane the state of Task |
|           |                         |
**



** Org GTD
Org-gtd integrates with Org-mode to manage GTD workflows effectively.

[[https://github.com/Trevoke/org-gtd.el/blob/master/doc/org-gtd.org][Org gtd manual-Github]]

Org-gtd uses ~org-edna~ to automate task state transitions., when you mark a ~NEXT~ item from a project as ~DONE~, the next ~TODO~ task automatically becomes ~NEXT~.

the default keywords for state of tasks are ~NEXT~, ~TODO~, ~WAIT~, ~CNCL~, and ~DONE~, but you can customize.

*The GTD Flow*
1. Capture Tasks
   Use ~<leader>-d t~ to capture things. Captured tasks are stored in the ~inbox.org~ file located in your ~org-gtd-directory~.

2. Processing the Inbox
   After capturing tasks, use ~<leader> d p~ to start processing the inbox. this starts a looping behavior of clarifying each item in the inbox.

3. Clarifing Tasks
   Clarifying tasks involves editing and adding the information to amke the task actionable.
   Clarify an Org heading, with ~<leader> d c c~.
   Clarify an item from the Agenda view, with ~<leader> d c a~.

   During clarification:
   Takss are displaying in an Org-mode buffer using ~org-gtd-clarify-mode~, a minor mode for task clarification.

   Working with Project Templates:
   If clarifying a project, you can insert templates using ~org-gtd-clarify-project-insert-template~.
   Define templates as an alist of (name . template) fairs.

   This is just example template

   #+begin_src emacs-lisp
   ;; (setq org-gtd-clarify-project-templates
   ;;    '(("Basic Project" . "* TODO %?\n** TODO First Task\n** TODO Second Task")
   ;;      ("Detailed Project" . "* TODO %?\n** TODO Define Scope\n** TODO Develop Timeline\n** TODO Execute")))
   #+end_src

4. Organizing items
   Once tasks are clarified, use <leader> d o to open the Organizing menu. This menu lets you categorize tasks into different types:
   - [P]rojects
   - [A]dd to existing project
   - [C]alendar
   - [D]elegate
   - [S]ingle action
   - [H]abit, org-mode-style habit
   - [I]ncubate, review later.
   - [Q]uick action, Less than 2min.
   - [K]nowledge
   - [T]rash

   Organizing tasks consists of three steps:
   1. Choosing a task type.
   2. Adding relevant metadata using hooks.
   3. Refilling the task into its appropriate location (e.g., Next Actions, Projects, etc.).

#+begin_src emacs-lisp
(setq org-gtd-update-ack "3.0.0") ;; 이것 없이 reload하면 warning이 뜸.

(use-package! org-gtd
  :after org
  :config
  (org-gtd-mode 1) ;; org-gtd-mode enable
  (setq org-gtd-directory (expand-file-name "GTD" org-directory))
        ;; org-gtd-default-files (expand-file-name "inbox.org" org-gtd-directory))
  (map! :leader
        (:prefix ("d" . "org-gtd")
        :desc "Capture thing"      "t" #'org-gtd-capture
        :desc "Process inbox"      "p" #'org-gtd-process-inbox
        :desc "Clarify item"       "l" #'org-gtd-clarify-item
        :desc "Engage"             "e" #'org-gtd-engage
        :desc "Show all Next"      "n" #'org-gtd-show-all-next
        :desc "Show Missed item"   "m" #'org-gtd-oops
        "ff" #'org-gtd-area-of-focus-set-on-item-at-point
        "fa" #'org-gtd-area-of-focus-set-on-agenda-item
        "s" #'org-gtd-review-stuck-projects
        ))
  (map! :map org-gtd-clarify-map
        :leader
        (:prefix ("d" . "org-gtd")
        :desc "Organize item"  "o" #'org-gtd-organize)))
#+end_src

*Task and Project*
Task와 Project는 모드 Org-mode의 헤딩으로 작성된다. Task는 하위 헤딩이 없고, Project는 상위 헤딩과 그 아래에 하위 헤딩들로 구성되어 있다.

*Engaging GTD items*
   After organizing tasks, you can engage with your workflow using these commands:
   View all ~NEXT~ actions, and scheduled tasks, with ~<leader> d e~.
   View only ~NEXT~ actions (no scheduled items), with ~<leader> d n~
   Handle missed appointments or tasks, with ~<leader> d m~

*GTD Horizons*
Org-GTD Provide ~Horizon 2 (Areas of Focus)

~org-gtd-area-of-focus~ each representing one of my areas of focus.
I ensures each item I clarify will need to be part of a horizon (area of focus).

,#+begin_src emacs-lisp
(setq org-gtd-areas-of-focus '("Finance" "Health")
      org-gtd-organize-hooks '(org-gtd-set-area-of-focus))
#+end_src

The longer-term horizons can be stored in a file in the ~org-gtd-directory~.
#+begin_src emacs-lisp
;; (setq org-gtd-horizons-file (expand-file-name "horizons.org" org-gtd-directory)
      ;; org-gtd-clarify-show-horizons 'right)
#+end_src

*Archiving / Cleaning up Completed Work*
You an clean up completed tasks and keep your active GTD files focused only on actionable or pending items.

Org-gtd Automatic archiving completed items (~DONE~ or ~CANCELD~). org-gtd scans your files in the ~org-gtd-directory~ to identify completed items and moves these items to an archive location based on ~org-archive-location~

You can manualy archiving, with ~org-gtd-archive-completed-items~, this will processes all Org files in ~org-gtd-directory~, identifies completed tasks, and move  them to the archive. So you can run it weekly or monthly to maintani a clean system.

*Applying hooks*
The decorations (priority, tags, categories, etc.) are customizable as you desire and managed by org-gtd-organize-hooks, a list of functions. You can add your own functions to this list,

*Lost Tasks*
org-gtd-review-stuck-calendar-items
org-gtd-review-stuck-incubated-items
org-gtd-review-stuck-habit-items
org-gtd-review-stuck-delegated-items
org-gtd-review-stuck-single-action-items
org-gtd-review-stuck-projects
org-gtd-review-missed-items

** Org Roam
[[https://github.com/org-roam/org-roam][Org-roam]] allows for effortless non-hierarchical note-taking. It is easy to create topic-focused Org files and link them together so that you can treat the information as nodes in a network rather than as hierarchical documents.

It's inspired by a program called Roam and a note-taking strategy called Zettlekasten where the goal is to create many individual single-topic notes that are linked together to create a "networked" knowledge base.

https://www.orgroam.com/manual.html

Org-roam crawls all files within ~org-roam-directory~, and maintains a cache of all links and nodes.

#+begin_src emacs-lisp
(setq org-roam-directory my/wiki-dir) ;; wiki file
(setq org-roam-db-location (expand-file-name "org-roam.db" org-roam-directory)) ;; DB file
#+end_src

Node is any headline or top level file with an ID. If you set ID can both set in file and headline. headlines without IDs will not be considered Org-roam nodes.

During the cache-build process, Org-roam generates a lot of in-memory data-structures which are discarded after use. To  reduce the number of garbage collection processes set this:

#+begin_src emacs-lisp
(org-roam-db-autosync-enable)
(setq org-roam-db-gc-threshold most-positive-fixnum)
#+end_src

다음은 org-mode-map에서의 키 바인딩이다.

|------------+----------------------------------------------------|
| Keybind    | Description                                        |
|------------+----------------------------------------------------|
| <ll> m D   | Demotes the entire buffer                          |
| <ll> m f   | Finds a node                                       |
| <ll> m F   | Finds a reference node                             |
| <ll> m g   | Generates the graph                                |
| <ll> m i   | Inserts a link to a node                           |
| <ll> m I   | Creates an ID for the node                         |
| <ll> m m   | Toggles the Org-roam buffer                        |
| <ll> m M   | Displays the Org-roam buffer as a dedicated window |
| <ll> m n   | Captures a new node                                |
| <ll> m r   | Refiles the current node                           |
| <ll> m R   | Replaces all links                                 |
| <ll> m d b | Goes to the previous daily note                    |
| <ll> m d d | Goes to a specific date                            |
| <ll> m d D | Captures a note for a specific date                |
| <ll> m d f | Goes to the next daily note                        |
| <ll> m d m | Goes to tomorrow's daily note                      |
| <ll> m d M | Captures tomorrow's daily note                     |
| <ll> m d n | Captures today's daily note                        |
| <ll> m d t | Goes to today's daily note                         |
| <ll> m d T | Captures today's daily note                        |
| <ll> m d y | Goes to yesterday's daily note                     |
| <ll> m d Y | Captures yesterday's daily note                    |
| <ll> m d - | Finds the dailies directory                        |
| <ll> m o a | Adds an alias to the current node                  |
| <ll> m o A | Removes an alias from the current node             |
| <ll> m o t | Adds a tag to the current node                     |
| <ll> m o T | Removes a tag from the current node                |
| <ll> m o r | Adds a reference to the current node               |
| <ll> m o R | Removes a reference from the current node          |
|------------+----------------------------------------------------|

*** Org Roam Buffer
The Org-roam buffer can tracks the node at point. It displays backlink, properties, metadata. To configure what sections are displayed in the buffer, set ~org-roam-mode-sections~.

#+begin_src emacs-lisp
(setq org-roam-mode-sections
      (list #'org-roam-backlinks-section
            #'org-roam-reflinks-section
            #'org-roam-unlinked-references-section))
#+end_src


Configure the org-roam buffer display:

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
             '("\\*org-roam\\*"
               (display-buffer-in-side-window)
               (side . right)
               (slot . 0)
               (window-width . 0.23) ;; 너무 좁으면 0.33으로 설정
               (window-parameters . ((no-other-window . t)
                                     (no-delete-other-windows . t)))))

;; TODO 뭔지 모르겠음
;; (defun org-roam-buffer-setup ()
;;   "Function to make org-roam-buffer more pretty."
;;   (progn
;;     (setq-local olivetti-body-width 44)
;;     (variable-pitch-mode 1)
;;     (olivetti-mode 1)
;;     (centaur-tabs-local-mode -1)

;;   (set-face-background 'magit-section-highlight (face-background 'default))))

;; (after! org-roam
;; (add-hook! 'org-roam-mode-hook #'org-roam-buffer-setup))
#+end_src

*** Node Properties
*Standard Properties*
Org-roam caches most of the standard Org properties. The fill list now includes:
- outline level
- todo state
- priority
- scheduled
- deadline
- tags

*Title & Aliases*
Each node has a single title. For file nodes, this is specified with the ‘#+title‘ property for the file. For headline nodes, this is the main text.

Nodes can also have multiple aliases. Aliases allow searching for nodes via an alternative name. To assign an alias to a node, add the ~ROAM_ALIASES~ property to the node or you can use key bindings.

*Tags*
Org-roam have two level of tags; file-level tags and headline tags. Tags for file-level nodes is set by the ~#+filetags~ keywords, as well as other tags the file may inherited.  Tags for headline level nodes are regulare Org tags.

Note that the ~#+filestags~ keyword impossible for selective tag inheritance, either tag inheritance is turned off, or all headline nodes will inherit the tags form th file nodes.

*Refs*
Refs are unique identifiers for nodes. These keys allow references to the key to show up in the Org-roam buffer. To add a ref, add to the ~ROAM_REFS~ property. you can assign multiple refs to a single node.

#+begin_src emacs-lisp
(after! org-roam
  (map! :map org-mode-map
      :localleader
      :prefix ("m" . "org-roam")
      "o" nil  ;; Remove doom keybind for node properties
      (:prefix ("p" . "node properties")
       "a" #'org-roam-alias-add
       "A" #'org-roam-alias-remove
       "t" #'org-roam-tag-add
       "T" #'org-roam-tag-remove
       "r" #'org-roam-ref-add
       "R" #'org-roam-ref-remove)))
#+end_src


|------------+--------------|
| Keybind    | Description  |
|------------+--------------|
| <ll> m p a | Add alias    |
| <ll> m p A | Remove alias |
| <ll> m p t | Add tag      |
| <ll> m p T | Remove tag   |
| <ll> m p r | Add ref      |
| <ll> m p R | Remove ref   |
|-           |              |

*** Templating System
Org-roam extends the ~org-capture~ system. providing a smoother note-taking experiece. Howerer, these extensions mean Org-roam capture templates are incompatible with ~org-capture~ templates.

See the org-roam-capture-templates documentation for more details and customization options.

# 12.2 Org-roam Template Expansion
# Org-roam’s template definitions also extend org-capture’s template syntax, to allow prefilling of strings. We have seen a glimpse of this in Template Walkthrough.

# Org-roam provides the ${foo} syntax for substituting variables with known strings. ${foo}’s substitution is performed as follows:

# If foo is a function, foo is called with the current node as its argument.
# Else if org-roam-node-foo is a function, foo is called with the current node as its argument. The org-roam-node- prefix defines many of Org-roam’s node accessors such as org-roam-node-title and org-roam-node-level.
# Else look up org-roam-capture--info for foo. This is an internal variable that is set before the capture process begins.
# If none of the above applies, read a string using completing-read.
# Org-roam also provides the ${foo=default_val} syntax, where if a default value is provided, will be the initial value for the foo key during minibuffer completion.
# One can check the list of available keys for nodes by inspecting the org-roam-node struct. At the time of writing, it is:

# (cl-defstruct (org-roam-node (:constructor org-roam-node-create)
#                              (:copier nil))
#   "A heading or top level file with an assigned ID property."
#   file file-hash file-atime file-mtime
#   id level point todo priority scheduled deadline title properties olp
#   tags aliases refs)
# This makes ${file}, ${file-hash} etc. all valid substitutions.


*** Extensions

아직 설정하지 않았기 때문에 설정하려면 다음 사이트를 참고하자. [[https://www.orgroam.com/manual.html#Installation-_00281_0029][org roam-manual]]
Org-roam provides extensions for capturing content from externak applications such as the brower, via ~org-protocol~. Org-roam extends ~org-protocol~ with 2 procotols: the ~roam-node~ and ~roam-ref~ protocols.

to use ~prg-protocol~, once must:
1. launch the ~emacsclient~ process
2. Register ~org-protocol:..~ as a valid scheme-handler
]
#+begin_src emacs-lisp
;; (require 'org-roam-protocol)
#+end_src


*org-roam-export*
Org-roam relies heeavily on ID links, which Org's html export has poor support. To fix this, Org-roam provides a bunch of overrides to better support export.
#+begin_src emacs-lisp
;; (require 'org-roam-export)
#+end_src


*Graphs(org-roam-ui)*
#+begin_src emacs-lisp
;; (use-package! org-roam
;;   :after org
;;   :config
;;   (setq org-roam-v2-ack t)
;;   (setq org-roam-mode-sections
;;         (list #'org-roam-backlinks-insert-section
;;               #'org-roam-reflinks-insert-section
;;               #'org-roam-unlinked-references-insert-section))
;;   (org-roam-db-autosync-enable))

;; (use-package! org-roam-ui
;;   :after org-roam
;;   :config
;;   (setq org-roam-ui-open-on-start nil)
;;   (setq org-roam-ui-browser-function #'xwidget-webkit-browse-url))

;; (use-package! websocket
;;   :after org-roam)

;;  (use-package! org-roam-ui
;;    :after org-roam
;;    :commands org-roam-ui-open
;;    :config
;;    (setq org-roam-ui-sync-theme t
;;          org-roam-ui-follow t
;;          org-roam-ui-update-on-save t
;;          org-roam-ui-open-on-start t))
;;  (after! org-roam
;;  (setq +org-roam-open-buffer-on-find-file nil))
 #+end_src

다음은 org-roam-mode-map에서의 magit 키 바인딩이다.
#+begin_src emacs-lisp

    ;; (map! :map org-roam-mode-map
    ;;       :nv "]"       #'magit-section-forward-sibling
    ;;       :nv "["       #'magit-section-backward-sibling
    ;;       :nv "gj"      #'magit-section-forward-sibling
    ;;       :nv "gk"      #'magit-section-backward-sibling
    ;;       :nv "gr"      #'revert-buffer
    ;;       :nv "gR"      #'revert-buffer
    ;;       :nv "z1"      #'magit-section-show-level-1
    ;;       :nv "z2"      #'magit-section-show-level-2
    ;;       :nv "z3"      #'magit-section-show-level-3
    ;;       :nv "z4"      #'magit-section-show-level-4
    ;;       :nv "za"      #'magit-section-toggle
    ;;       :nv "zc"      #'magit-section-hide
    ;;       :nv "zC"      #'magit-section-hide-children
    ;;       :nv "zo"      #'magit-section-show
    ;;       :nv "zO"      #'magit-section-show-children
    ;;       :nv "zm"      #'magit-section-show-level-2-all
    ;;       :nv "zr"      #'magit-section-show-level-4-all
    ;;       :nv "C-j"     #'magit-section-forward
    ;;       :nv "C-k"     #'magit-section-backward
    ;;       :g  "M-p"     #'magit-section-backward-sibling
    ;;       :g  "M-n"     #'magit-section-forward-sibling
    ;;       :g  [tab]     #'magit-section-toggle
    ;;       :g  [C-tab]   #'magit-section-cycle
    ;;       :g  [backtab] #'magit-section-cycle-global)))
#+end_src


Org-roam에서 파일을 암호화하려면 파일 확장자를 ~.gpg~ 로 설정하면 된다. 이를 위해 Org-roam 캡쳐 템플릿에 ~.gpg~ 확장자를 추가해야 한다. 아직은 사용하지 않으므로 해제하였다.
#+begin_src emacs-lisp
;; (setq org-roam-capture-templates
;;       '(("p" "Private Note" plain "%?"
;;          :target (file+head "private/${slug}.org.gpg"
;;                             "#+title: ${title}\n")
;;          :unnarrowed t)))
#+end_src

** Org Capture
:PROPERTIES:
:ID:       Org-workflow-2025-01-06-21-19-13
:END:

Captrue 템플릿 만들기

Journal 템플릿에서 =entry= 타입은 Org-mode의 헤딩 형식을 갖춘 문자열 또는 리스트를 템플릿으로 가져야 한다. 다만 함수에서 헤딩을 생성하고 있으므로, 템플릿에는 본문만 있으면 된다. 따라서 타입을 =plain=으로 바꿨다.

#+begin_src emacs-lisp
(setq org-capture-templates
       `(("j" "Journal" plain
          (function my/journal-entry)
          "%?"
          :jump-to-captured t
          :empty-lines 1)

         ("i" "Inbox" entry
          (file "inbox.org")
          "* TODO %?\n /Entered on/ %U")))
#+end_src

Journal Capture 템플릿 함수다. 해당 월의 파일을 찾아 열고, 오늘 날짜에 맞는 헤딩으로 이동하거나 생성한다.

#+begin_src emacs-lisp
(defun my/journal-entry ()
  "Find or create a heading in the appropriate monthly journal file."
  (let* ((today (format-time-string "%Y-%m-%d"))
         (day (format-time-string "%a"))
         (heading (format "%s (%s)" today day))
         (file (expand-file-name
                (format "100-Notes/Journal/%s.org" (substring today 0 7))
                org-directory)))
    (unless (file-exists-p file)
      (with-temp-buffer (write-file file)))
    (find-file file)
    (goto-char (point-min))
    (if (re-search-forward (format "^\\* %s$" (regexp-quote heading)) nil t)
        (goto-char (match-beginning 0))
      (goto-char (point-max))
      (unless (bolp) (insert "\n"))
      (insert (format "* %s\n" heading)))
    (list file (point))))
  #+end_src


키 바인딩하기

#+begin_src emacs-lisp
(defun org-capture-inbox ()
  (interactive)
  (call-interactively 'org-store-link)
  (org-capture nil "i"))

(map! :desc "Add todo to inbox" :n "C-c i" #'org-capture-inbox)
#+end_src

#+begin_src emacs-lisp
(map! :leader
      :desc "Org agenda" :n "a" #'org-agenda)
#+end_src

#+begin_src emacs-lisp
(setq org-agenda-hide-tags-regexp "inbox")
#+end_src

- [ ] 지울 수 없음

#+begin_src emacs-lisp
;; (setq org-agenda-prefix-format
;;       '((agenda . " %i %-12:c%?-12t% s")
;;         (todo   . " ")
;;         (tags   . " %i %-12:c")
;;         (search . " %i %-12:c")))
#+end_src






** Org-Latex


Allows you to jump in and out of latex fragments without using ~C-c C-x C-l~ all the time.
# (use-package! org-fragtog
#   :after org
#   :hook (org-mode . org-fragtog-mode)
#   )




* TODO Screenshot


** TODO Emacs Everywhere

* Applications
** TODO vterm
#+begin_quote
Part of the ~term vterm~ modules. powerd by ~libvterm~
#+end_quote

[[https://github.com/akermu/emacs-libvterm][vterm]] is as good as terminal emulation gets in Emacs and the most performant. vterm not available in Windows.


| Keybind      | Description                                           |
|--------------+-------------------------------------------------------|
| <leader> o t | Toggle vterm pop up window in the current project.org |
| <leader> o T | Opens vterm in the current window.                    |

다음 dotfiles을 참고하자.
https://github.com/elken/.files

기본 쉘 대신 zsh쉘을 사용한다.

#+begin_src emacs-lisp
(setq vterm-shell "/bin/zsh")
#+end_src

#+begin_src emacs-lisp
;; (setq vterm-always-compile-module t) ;; UNKNOWN
#+end_src

If the precess exits, kill the ~vterm~ buffer

#+begin_src emacs-lisp
(setq vterm-kill-buffer-on-exit t)
#+end_src

Useful functions for the shell-side integration provided by vterm.

#+begin_src emacs-lisp
;; (after! vterm
;;   (setf (alist-get "woman" vterm-eval-cmds nil nil #'equal)
;;         '((lambda (topic)
;;             (woman topic))))
;;   (setf (alist-get "magit-status" vterm-eval-cmds nil nil #'equal)
;;         '((lambda (path)
;;             (magit-status path))))
;;   (setf (alist-get "dired" vterm-eval-cmds nil nil #'equal)
;;         '((lambda (dir)
;;             (dired dir)))))
#+end_src

** TODO Transient
** TODO Bitwarden
** TODO Calendar
# (use-package calendar
#   :straight (:type built-in)
#   :defer t
#   :general
#   (:keymaps 'calendar-mode-map
#    "»"     #'calendar-scroll-left
#    "«"     #'calendar-scroll-right
#    "M-»"   #'calendar-scroll-left-three-months
#    "M-«"   #'calendar-scroll-right-three-months
#    "M-r"   #'calendar-scroll-left
#    "M-c"   #'calendar-scroll-right
#    "M-S-r" #'calendar-scroll-left-three-months #    "M-S-c" #'calendar-scroll-right-three-months
#    "q"     #'calendar-exit)
#   (phundrak/major-leader-key
#     :keymaps 'calendar-mode-map
#     """   #'calendar-count-days-region
#     "^"   '(:ignore t :wk "beginning")
#     "^ w" #'calendar-beginning-of-week
#     "^ m" #'calendar-beginning-of-month
#     "^ y" #'calendar-beginning-of-year
#     "$"   '(:ignore t :wk "end")
#     "$w"  #'calendar-end-of-week
#     "$m"  #'calendar-end-of-month
#     "$y"  #'calendar-end-of-year
#     "a"   '(:ignore t :wk "appointment")
#     "aa"  #'appt-add
#     "ad"  #'appt-delete
#     "A"   #'org-calendar-goto-agenda
#     "b"   '(:ignore t :wk "go back")
#     "bd"  '(calendar-backward-day :wk "a day")
#     "bw"  '(calendar-backward-week :wk "a week")
#     "bm"  '(calendar-backward-month :wk "a month")
#     "by"  '(calendar-backward-year :wk "a year")
#     "d"   '(:ignore t :wk "diary")
#     "da"  '(diary-show-all-entries :wk "all entries")
#     "dd"  '(diary-view-entries :wk "entries")
#     "dm"  #'diary-mark-entries
#     "do"  #'diary-view-other-diary-entries
#     "di"  '(:ignore t :wk "insert")
#     "die" '(diary-insert-entry :wk "entry")
#     "die" '(diary-insert-block-entry :wk "block entry")
#     "diw" '(diary-insert-weekly-entry :wk "weekly")
#     "dim" '(diary-insert-monthly-entry :wk "monthly")
#     "diy" '(diary-insert-yearly-entry :wk "yearly")
#     "F"   '(:ignore t :wk "files")
#     "Fa"  #'org-calendar-goto-agenda
#     "f"   '(:ignore t :wk "go forward")
#     "fd"  '(calendar-forward-day :wk "a day")
#     "fw"  '(calendar-forward-week :wk "a week")
#     "fm"  '(calendar-forward-month :wk "a month")
#     "fy"  '(calendar-forward-year :wk "a year")
#     "g"   '(:ignore t :wk "goto")
#     "gd"  #'calendar-goto-date
#     "gm"  #'calendar-other-month
#     "gt"  #'calendar-goto-today
#     "h"   '(:ignore t :wk "holidays")
#     "hl"  #'calendar-list-holidays
#     "hm"  #'calendar-mark-holidays
#     "H"   '(:ignore t :wk "HTML export")
#     "Hm"  #'cal-html-cursor-month
#     "Hy"  #'cal-html-cursor-year
#     "M"   #'calendar-other-month))

** TODO Docker
# (use-package dockerfile-mode
#   :defer t
#   :straight (:build t)
#   :hook (dockerfile-mode . lsp-deferred)
#   :init
#   (put 'docker-image-name 'safe-local-variable #'stringp)
#   :mode "Dockerfile\\'"
#   :general
#   (phundrak/major-leader-key
#    :keymaps 'general-mode-map
#    :packages 'lsp-mode
#    "l"  '(:keymap lsp-command-map :which-key "lsp")))
# The docker package also provides interactivity with Docker and docker-compose from Emacs.


# (use-package docker
#   :defer t
#   :straight (:build t))














** Elefeed
An RSS newfeed reader for Emacs.


#+begin_src emacs-lisp

(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :n "q" #'+rss/quit
      :n "e" #'elfeed-update
      :n "r" #'elfeed-search-untag-all-unread
      :n "u" #'elfeed-search-tag-all-unread
      :n "s" #'elfeed-search-live-filter
      :n "RET" #'elfeed-search-show-entry
      :n "p" #'elfeed-show-pdf
      :n "+" #'elfeed-search-tag-all
      :n "-" #'elfeed-search-untag-all
      :n "S" #'elfeed-search-set-filter
      :n "b" #'elfeed-search-browse-url
      :n "y" #'elfeed-search-yank)

(map! :map elfeed-show-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :nm "q" #'+rss/delete-pane
      :nm "o" #'ace-link-elfeed
      :nm "RET" #'org-ref-elfeed-add
      :nm "n" #'elfeed-show-next
      :nm "N" #'elfeed-show-prev
      :nm "p" #'elfeed-show-pdf
      :nm "+" #'elfeed-show-tag
      :nm "-" #'elfeed-show-untag
      :nm "s" #'elfeed-show-new-live-search
      :nm "y" #'elfeed-show-yank)

(after! elfeed-search
  (set-evil-initial-state! 'elfeed-search-mode 'normal))
(after! elfeed-show-mode
  (set-evil-initial-state! 'elfeed-show-mode   'normal))
;; (setq elfeed-goodies/entry-pane-size 0.5)


#+end_src

다른 dotfiles에서 복붙 해온 것이기 때문에 모르는 사이트 들이 많다. 추후에 확인하기
#+begin_src emacs-lisp
(setq elfeed-feeds (quote
                    (("https://www.reddit.com/r/emacs.rss" reddit emacs)
                     ;; ("https://hackaday.com/blog/feed/" hackaday linux)
                     ;; ("https://opensource.com/feed" opensource linux)
                     ;; ("https://itsfoss.com/feed/" itsfoss linux)
                     ;; ("https://www.zdnet.com/topic/linux/rss.xml" zdnet linux)
                     ;; ("https://www.computerworld.com/index.rss" computerworld linux)
                     ;; ("https://www.networkworld.com/category/linux/index.rss" networkworld linux)
                     ;; ("https://www.techrepublic.com/rssfeeds/topic/open-source/" techrepublic linux)
                     ;; ("https://betanews.com/feed" betanews linux)
                     ;; ("http://lxer.com/module/newswire/headlines.rss" lxer linux)
                     )))


#+end_src

Visual enhancements
#+begin_src emacs-lisp
(after! elfeed

  (elfeed-org)
  (use-package! elfeed-link)

  (setq elfeed-search-filter "@1-week-ago +unread"
        elfeed-search-print-entry-function '+rss/elfeed-search-print-entry
        elfeed-search-title-min-width 80
        elfeed-show-entry-switch #'pop-to-buffer
        elfeed-show-entry-delete #'+rss/delete-pane
        elfeed-show-refresh-function #'+rss/elfeed-show-refresh--better-style
        shr-max-image-proportion 0.6)

  (add-hook! 'elfeed-show-mode-hook (hide-mode-line-mode 1))
  (add-hook! 'elfeed-search-update-hook #'hide-mode-line-mode)

  (defface elfeed-show-title-face '((t (:weight ultrabold :slant italic :height 1.5)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (defface elfeed-show-author-face `((t (:weight light)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (set-face-attribute 'elfeed-search-title-face nil
                      :foreground 'nil
                      :weight 'light)

  (defadvice! +rss-elfeed-wrap-h-nicer ()
    "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
    :override #'+rss-elfeed-wrap-h
    (setq-local truncate-lines nil
                shr-width 120
                visual-fill-column-center-text t
                default-text-properties '(line-height 1.1))
    (let ((inhibit-read-only t)
          (inhibit-modification-hooks t))
      (visual-fill-column-mode)
      ;; (setq-local shr-current-font '(:family "Merriweather" :height 1.2))
      (set-buffer-modified-p nil)))

  (defun +rss/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer."
    (let* ((elfeed-goodies/tag-column-width 40)
           (elfeed-goodies/feed-source-column-width 30)
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat (mapconcat 'identity tags ",")))
           (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                           elfeed-goodies/tag-column-width 4))

           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left)))

      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
      (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
      (insert (propertize title 'face title-faces 'kbd-help title))
      (setq-local line-spacing 0.2)))

  (defun +rss/elfeed-show-refresh--better-style ()
    "Update the buffer to match the selected entry, using a mail-style."
    (interactive)
    (let* ((inhibit-read-only t)
           (title (elfeed-entry-title elfeed-show-entry))
           (date (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (author (elfeed-meta elfeed-show-entry :author))
           (link (elfeed-entry-link elfeed-show-entry))
           (tags (elfeed-entry-tags elfeed-show-entry))
           (tagsstr (mapconcat #'symbol-name tags ", "))
           (nicedate (format-time-string "%a, %e %b %Y %T %Z" date))
           (content (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (type (elfeed-entry-content-type elfeed-show-entry))
           (feed (elfeed-entry-feed elfeed-show-entry))
           (feed-title (elfeed-feed-title feed))
           (base (and feed (elfeed-compute-base (elfeed-feed-url feed)))))
      (erase-buffer)
      (insert "\n")
      (insert (format "%s\n\n" (propertize title 'face 'elfeed-show-title-face)))
      (insert (format "%s\t" (propertize feed-title 'face 'elfeed-search-feed-face)))
      (when (and author elfeed-show-entry-author)
        (insert (format "%s\n" (propertize author 'face 'elfeed-show-author-face))))
      (insert (format "%s\n\n" (propertize nicedate 'face 'elfeed-log-date-face)))
      (when tags
        (insert (format "%s\n"
                        (propertize tagsstr 'face 'elfeed-search-tag-face))))
      ;; (insert (propertize "Link: " 'face 'message-header-name))
      ;; (elfeed-insert-link link link)
      ;; (insert "\n")
      (cl-loop for enclosure in (elfeed-entry-enclosures elfeed-show-entry)
               do (insert (propertize "Enclosure: " 'face 'message-header-name))
               do (elfeed-insert-link (car enclosure))
               do (insert "\n"))
      (insert "\n")
      (if content
          (if (eq type 'html)
              (elfeed-insert-html content base)
            (insert content))
        (insert (propertize "(empty)\n" 'face 'italic)))
      (goto-char (point-min))))
  )
#+end_src

Functionality enhancements
#+begin_src emacs-lisp
(after! elfeed-show
  (require 'url)

  (defvar elfeed-pdf-dir
    (expand-file-name "pdfs/"
                      (file-name-directory (directory-file-name elfeed-enclosure-default-dir))))

  (defvar elfeed-link-pdfs
    '(("https://www.jstatsoft.org/index.php/jss/article/view/v0\\([^/]+\\)" . "https://www.jstatsoft.org/index.php/jss/article/view/v0\\1/v\\1.pdf")
      ("http://arxiv.org/abs/\\([^/]+\\)" . "https://arxiv.org/pdf/\\1.pdf"))
    "List of alists of the form (REGEX-FOR-LINK . FORM-FOR-PDF)")

  (defun elfeed-show-pdf (entry)
    (interactive
     (list (or elfeed-show-entry (elfeed-search-selected :ignore-region))))
    (let ((link (elfeed-entry-link entry))
          (feed-name (plist-get (elfeed-feed-meta (elfeed-entry-feed entry)) :title))
          (title (elfeed-entry-title entry))
          (file-view-function
           (lambda (f)
             (when elfeed-show-entry
               (elfeed-kill-buffer))
             (pop-to-buffer (find-file-noselect f))))
          pdf)

      (let ((file (expand-file-name
                   (concat (subst-char-in-string ?/ ?, title) ".pdf")
                   (expand-file-name (subst-char-in-string ?/ ?, feed-name)
                                     elfeed-pdf-dir))))
        (if (file-exists-p file)
            (funcall file-view-function file)
          (dolist (link-pdf elfeed-link-pdfs)
            (when (and (string-match-p (car link-pdf) link)
                       (not pdf))
              (setq pdf (replace-regexp-in-string (car link-pdf) (cdr link-pdf) link))))
          (if (not pdf)
              (message "No associated PDF for entry")
            (message "Fetching %s" pdf)
            (unless (file-exists-p (file-name-directory file))
              (make-directory (file-name-directory file) t))
            (url-copy-file pdf file)
            (funcall file-view-function file))))))

  )
#+end_src

* Magit
* Python

* Footnotes


{printeflj} ksdlfj

* Evil-surround

- [ ] 현재 커서에 바로 서라운딩 추가하기 특히 ~ysiw~

| Keybind                          | Description        |
|----------------------------------+--------------------|
| [V] S<textobj>                   | Add surrounding    |
| [N] ys<textobj>                  | Add surrounding    |
| [N] cs<old-textobj><new-textobj> | Change surrounding |
| [N] ds<textobj>                  | Delete surrounding |

surround 추가는 해당 repo에서 찾아보자
.

* Translate
[[https://github.com/lorniu/go-translate][go-translate]]는






* DONE Sync
** Sync wiki
내가 원하는 것은 모바일에서도 로컬에서 다루는 org 문서 파일을 열람 및 수정할 수 있게 만드는 것이다.

파일 동기화의 두 가지 방식
1. 서버에 파일을 올리고, PC 또는 모바일에 서버의 파일들을 링크시키는 방식. 어느 파일이 수정 전후인지 구분할 수 있어서 파일 동기화가 편리하다는 장점이 있다.
2. 로컬과 서버 모두 파일이 존재해서 최신본 파일로 동기화시키는 방식. 장점은 오프라인 상태에서도 파일을 열람 및 수정 가능하다는 점이다.

나는 폰과 모바일 둘다 두번째 방식을 사용하기로 했다.

- 로컬 컴퓨터와 구글 드라이브 연동
  1. arch linux에 rclone 설치
     =sudo pacman -S rclone=
  2. rclone config 실행
     =rclone config=
  3. 새 리모트 추가 (n)
  4. 이름 입력 (drive)
  5. 스토리지 유형 (drive)
  6. 나머지는 enter 누르면 됨.
  7. 최신 파일 기준으로 양방향 동기화
     =rclone bisync ~/wiki drive:wiki --resync= (=--resync= 는 최초 실행시 필수)
     =rclone bisync ~/wiki drive:wiki=
- 구글 드라이브와 안드로이드 기기의 연동
  'DriveSync'라는 어플을 통해서 구글 드라이브의 파일을 안드로이드 기기 내에 연동시킬 수 있다.

동기화 스크립트는 다음과 같은 상황에서 실행된다.
- 컴퓨터가 부팅된 후에
- emacs 종료 전에
- 단축키 실행
#+begin_src emacs-lisp
(defun my/run-sync-wiki ()
  "Run sync_wiki script."
  (interactive)
  (start-process-shell-command "sync-wiki" nil "~/.config/hypr/scripts/sync_wiki"))

;; Run wiki_sync script before Emacs exits.
(add-hook 'kill-emacs-hook #'my/run-sync-wiki)

(map! :desc "Run wiki sync" :n "= w" #'my/run-sync-wiki​) ;; FIXME
#+end_src

** Sync dotfiles
dotfiles를 수정한 후 github에 push 할 수 있도록 키 바인딩을 했다.

#+begin_src emacs-lisp
(defun my/push-dotfiles ()
  "Run push-dotfiles script."
  (interactive)
  (start-process-shell-command "push-dotfiles" nil "~/.config/hypr/scripts/push_dotfiles"))

(map! :desc "Push dotfiles" :n "= d" #'my/push-dotfiles)
#+end_src

